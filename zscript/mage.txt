class ReforgedMage : RPGPlayer
{
	Default
	{
		Radius 16;
		Height 64;
		PainSound "PlayerMagePain";
		Player.JumpZ 9;
		Player.Viewheight 48;
		Player.SpawnClass "Mage";
		Player.DisplayName "Mage";
		Player.SoundClass "mage";
		Player.ScoreIcon "MAGEFACE";
		Player.StartItem "ReforgedWand";
		Player.StartItem "AmuletPiece";
		Player.StartItem "BlueMana", 100;
		Player.StartItem "GreenMana", 100;
		Player.StartItem "RedMana", 0;
		Player.Portrait "P_MWALK1";
		Player.WeaponSlot 1, "ReforgedWand";
		Player.WeaponSlot 2, "ReforgedFrost";
		Player.WeaponSlot 3, "ReforgedLightning";
		Player.WeaponSlot 4, "MWeapBloodscourge";
		
		Player.ColorRange 146, 163;
		Player.Colorset		0, "$TXT_COLOR_BLUE",		146, 163,    161;
		Player.ColorsetFile 1, "$TXT_COLOR_RED",		"TRANTBL7",  0xB3;
		Player.ColorsetFile 2, "$TXT_COLOR_GOLD",		"TRANTBL8",  0x8C;
		Player.ColorsetFile 3, "$TXT_COLOR_DULLGREEN",	"TRANTBL9",  0x41;
		Player.ColorsetFile 4, "$TXT_COLOR_GREEN",		"TRANTBLA",  0xC9;
		Player.ColorsetFile 5, "$TXT_COLOR_GRAY",		"TRANTBLB",  0x30;
		Player.ColorsetFile 6, "$TXT_COLOR_BROWN",		"TRANTBLC",  0x72;
		Player.ColorsetFile 7, "$TXT_COLOR_PURPLE",		"TRANTBLD",  0xEE;
		
		+NOSKIN
	}

	States
	{
		Spawn:
			MAGE A -1;
			Stop;
			
		See:
			MAGE ABCD 4;
			Loop;
			
		Missile:
		Melee:
			MAGE EF 8;
			Goto Spawn;
			
		Pain:
			MAGE G 4;
			MAGE G 4 A_Pain;
			Goto Spawn;
			
		Death:
			MAGE H 6;
			MAGE I 6 A_PlayerScream;
			MAGE JK 6;
			MAGE L 6 A_NoBlocking;
			MAGE M 6;
			MAGE N -1;
			Stop;	
			
		XDeath:
			MAGE O 5 A_PlayerScream;
			MAGE P 5;
			MAGE R 5 A_NoBlocking;
			MAGE STUVW 5;
			MAGE X -1;
			Stop;
			
		Ice:
			MAGE Y 5 A_FreezeDeath;
			MAGE Y 1 A_FreezeDeathChunks;
			Wait;
			
		Burn:
			FDTH E 5 BRIGHT A_PlaySound("*burndeath");
			FDTH F 4 BRIGHT;
			FDTH G 5 BRIGHT;
			FDTH H 4 BRIGHT A_PlayerScream;
			FDTH I 5 BRIGHT;
			FDTH J 4 BRIGHT;
			FDTH K 5 BRIGHT;
			FDTH L 4 BRIGHT;
			FDTH M 5 BRIGHT;
			FDTH N 4 BRIGHT;
			FDTH O 5 BRIGHT;
			FDTH P 4 BRIGHT;
			FDTH Q 5 BRIGHT;
			FDTH R 4 BRIGHT;
			FDTH S 5 BRIGHT A_NoBlocking;
			FDTH T 4 BRIGHT;
			FDTH U 5 BRIGHT;
			FDTH V 4 BRIGHT;
			ACLO E 35 A_CheckPlayerDone;
			Wait;
			ACLO E 8;
			Stop;
	}
	
	override void InitializeSkills()
	{
		AddSkill("Desecrate");
		AddSkill("KineticBlast");
		
		AddSkill("LightningBulwark");
		AddSkill("Elementalist");
		AddSkill("Resurrect");
		AddSkill("Haste");
		AddSkill("IceNova");
		AddSkill("Shadow");
		AddSkill("Thunder");
		
		SetActiveSkill(0, "Desecrate");
		SetActiveSkill(1, "KineticBlast");
		SetActiveSkill(2, "LightningBulwark");
	}
	
	override void InitializeStats()
	{
		super.InitializeStats();
		
		for (uint i = 0; i < stats.Size(); ++i)
		{
			if (!stats[i])
				continue;
			
			let cls = stats[i].GetClass();
			if (cls == "Wisdom" || cls == "Intelligence")
				stats[i].LevelUp(2, true);
		}
	}
}

class UndeadTracer : LineTracer
{
	Actor master;
	
	override ETraceStatus TraceCallback()
	{
		switch (results.HitType)
		{
			case TRACE_HitWall:
				int blockFlags = Line.ML_BLOCKEVERYTHING;
				if (!(results.hitLine.flags & blockFlags) &&
					(results.hitLine.flags & Line.ML_TWOSIDED) &&
					results.tier == TIER_Middle)
				{
					results.hitType = TRACE_HitNone;
					break;
				}
			case TRACE_HasHitSky:
			case TRACE_HitFloor:
			case TRACE_HitCeiling:
				return TRACE_Stop;
				break;
			
			case TRACE_HitActor:
				if (results.hitActor != master && !master.IsFriend(results.hitActor) &&
					results.hitActor.bIsMonster && results.hitActor.health <= 0 &&
					results.hitActor.tics == -1)
				{
					return TRACE_Stop;
				}
				results.hitType = TRACE_HitNone;
				break;
		}
		
		return TRACE_Skip;
	}
}

class Desecrate : Skill
{
	Default
	{
		Skill.Type "GreenMana";
		Skill.ReserveType "RedMana";
		Inventory.Icon "PTN1A0";
		Tag "Desecrate";
		Skill.Description "Consume the corpse of a foe to yield a health pickup";
	}
	
	override void UseSkill()
	{
		if (!CheckAmmo(5, type, reserveType))
		{
			Console.Printf("You do not have enough resources to cast this");
			return;
		}
				
		let tracer = new("UndeadTracer");
		if (tracer)
		{
			Vector3 start = (owner.pos.xy, owner.player.viewz);
			Vector3 dir = (AngleToVector(owner.angle, cos(owner.pitch)), -sin(owner.pitch));
			tracer.master = owner;
			tracer.Trace(start, CurSector, dir, 256, 0);
			
			if (tracer.results.hitType == TRACE_HitActor)
			{
				TakeAmmo(5, type, reserveType);
				let mo = Spawn("ReforgedCrystalVial", tracer.results.hitActor.pos, ALLOW_REPLACE);
				if (mo && !mo.bNoGravity)
					mo.vel.z += 7;
				
				tracer.results.hitActor.Destroy();
			}
		}
	}
}

class KineticBlast : Skill
{
	Default
	{
		Skill.Cost 5;
		Skill.CastTime 22;
		Skill.Type "BlueMana";
		Skill.ReserveType "RedMana";
		Inventory.Icon "MWNDF0";
		Skill.Cast "KineticHands";
		Tag "Kinetic Blast";
		Skill.Description "Shoots out a projectile that, on impact, explodes into bouncing projectiles";
	}
	
	override void UseSkill()
	{
		let rpg = RPGPlayer(owner.player.mo);
		if (rpg)
			castTimer *= rpg.attackModifier;
	}
}

class BlastProjectile : RPGMissile
{
	Default
	{
		RPGMissile.AilmentPower 100;
		RPGMissile.AilmentType "Flinch";
		Speed 128;
		Radius 3;
		Height 6;
		Damage 100;
		DamageType "Blunt";
		SeeSound "MageWandFire";
		Obituary "$OB_MPMWEAPWAND";
		BounceFactor 1;
		WallBounceFactor 1;
		BounceCount 2;
		
		+SPAWNSOUNDSOURCE
		+RPGMISSILE.SHIELDBUSTER
		+BOUNCEONWALLS
		+BOUNCEONFLOORS
		+BOUNCEONCEILINGS
		+ALLOWBOUNCEONACTORS
		+BOUNCEONACTORS
		+DONTBOUNCEONSKY
	}
	
	States
	{
		Spawn:
			MWND CCCCDDDD 1 Bright
			{
				if (bounceCount <= 1)
				{
					pitch = -VectorAngle(vel.xy.Length(), vel.z);
					ExplodeMissile();
				}
			}
			Loop;
			
		Death:
			TNT1 A 1
			{
				Vector3 dir = (AngleToVector(angle, cos(pitch)), -sin(pitch));
				double ang = 0;
				
				for (int i = 0; i < 12; ++i)
				{
					let blast = Spawn("SmallBlastProjectile", pos, ALLOW_REPLACE);
					if (blast)
					{
						Vector3 newDir = RPGWeapon.GetNewDirection(self, dir, ang, absolute: true);
						
						blast.master = target;
						blast.target = target;
						blast.angle = VectorAngle(newDir.x, newDir.y);
						blast.vel = newDir*speed;
						let rpg = RPGMissile(blast);
						if (rpg)
							rpg.alreadyHit.Copy(alreadyHit);
					}
					
					ang += 30;
				}
			}
			Stop;
	}
}

class SmallBlastProjectile : BlastProjectile
{
	Default
	{
		Damage 20;
		BounceCount 2;
		
		+DONTBOUNCEONSHOOTABLES
		-RPGMISSILE.SHIELDBUSTER
		-SPAWNSOUNDSOURCE
	}
	
	States
	{
		Spawn:
			MWND CD 4 Bright;
			Loop;
			
		Death:
			MWND E 4 Bright;
			MWND F 3 Bright;
			MWND G 4 Bright;
			MWND H 3 Bright;
			MWND I 4 Bright;
			Stop;
	}
}

class KineticHands : CastWeapon
{
	Default
	{
		Weapon.YAdjust 20;
		Weapon.AmmoType1 "BlueMana";
		Weapon.AmmoType2 "RedMana";
	}
	
	States
	{
		Select:
		Deselect:
		Fire:
		Ready:
			CONE B 3;
			CONE C 4;
			CONE D 3;
			CONE E 5;
			TNT1 A 0 A_PlaySound ("MageShardsFire", CHAN_WEAPON);
			CONE F 3 A_NewProjectile("BlastProjectile");
			CONE G 3;
			Stop;
	}
}

class LightningBulwark : Skill
{
	Default
	{
		Skill.BuffType "LightningBulwarkBuff";
		Inventory.Icon "SHEXA0";
		Skill.Drain 4;
		Skill.DrainType "GreenMana";
		Skill.ReserveDrainType "RedMana";
		Tag "Lightning Bulwark";
		Skill.Description "Protect yourself in a barrier of electricity. Enemies that melee you shock it and nearby enemies";
		
		+SKILL.TOGGLE
		+SKILL.SPECIALDRAIN
	}
	
	override void UseSkill()
	{
		GiveBuff(owner);
	}
	
	override void EndSkill()
	{
		TakeBuff();
	}
}

class LightningBulwarkBuff : Buff
{
	Array<Actor> hitSources;
	
	Default
	{
		Inventory.Icon "SHEXA0";
		Buff.Cost 4;
		Buff.Type "GreenMana";
		Buff.ReserveType "RedMana";
		
		+BUFF.INFINITE
	}
	
	override void DoEffect()
	{
		hitSources.Clear();
		
		super.DoEffect();
	}
	
	override void ModifyDamage(int damage, Name damageType, out int newdamage, bool passive, Actor inflictor, Actor source, int flags)
	{
		if (!passive || !source || hitSources.Find(source) != hitSources.Size())
			return;
		
		if (inflictor == source || inflictor is "HurtBox")
		{
			BlockThingsIterator it = BlockThingsIterator.Create(owner, 128);
			Actor mo;
			
			while (it.Next())
			{
				mo = it.thing;
				if (!mo || mo == owner || mo.health <= 0 || !(mo.bIsMonster || mo.player) ||
					owner.IsFriend(mo) || owner.Distance3DSquared(mo) > 16384)
				{
					continue;
				}
				
				let shk = Shock(mo.FindInventory("Shock"));
				if (shk)
					shk.AddAilment(owner, 100);
				
				mo.DamageMobj(self, owner, 30, "Electric", DMG_NOBLOCK);
			}
			
			hitSources.Push(source);
			
			TakeAmmo(cost, type, reserveType);
		}
	}
}

class Elementalist : Skill
{
	Default
	{
		Skill.BuffType "ElementalistBuff";
		Inventory.Icon "DMFXA1";
		Tag "Elementalist";
		Skill.Description "Switch between ice and fire with your Frost Shards";
		
		+SKILL.TOGGLE
	}
	
	override void UseSkill()
	{
		GiveBuff(owner);
	}
	
	override void EndSkill()
	{
		TakeBuff();
	}
}

class ElementalistBuff : Buff
{
	Default
	{
		Inventory.Icon "DMFXA1";
		
		+BUFF.INFINITE
	}
}

class Resurrect : Skill
{
	const MAX_MINIONS = 5;
	
	Array<Actor> minions;
	
	Array<class<Actor> > minionName;
	Array<int> minionHealth;
	
	int prevLevelNum;
	
	Default
	{
		Skill.Type "BlueMana";
		Skill.ReserveType "RedMana";
		Inventory.Icon "MAN3A0";
		Tag "Resurrect";
		Skill.Description "Raise a slain foe to fight for you (max of 5 minions)";
	}
	
	override void ModifyDamage(int damage, Name damageType, out int newdamage, bool passive, Actor inflictor, Actor source, int flags)
	{
		if (damage <= 0)
			return;
		
		if (passive)
		{
			if (source && source.bIsMonster && !owner.IsFriend(source))
			{
				for (uint i = 0; i < minions.Size(); ++i)
				{
					if (minions[i] && !minions[i].target)
						minions[i].target = source;
				}
			}
		}
		else
		{
			// TODO: Find way to get thing player is attacking
			for (uint i = 0; i < minions.Size(); ++i)
			{
				if (minions[i] && !minions[i].target)
					minions[i].target = null;
			}
		}
	}
	
	override void Tick()
	{
		super.Tick();
		
		if (!prevLevelNum)
			prevLevelNum = level.levelNum;
		
		if (level.levelNum != prevLevelNum)
		{
			ThinkerIterator it = ThinkerIterator.Create("Actor", STAT_DEFAULT);
			Actor mo;
			
			while (mo = Actor(it.Next()))
			{
				if (mo && mo.bIsMonster && mo.master == owner && minions.Find(mo) == minions.Size())
					mo.Destroy();
			}
		}
		
		prevLevelNum = level.levelNum;
		
		for (uint i = 0; i < minions.Size(); ++i)
		{
			if (minions[i])
				minionHealth[i] = minions[i].health;
			else
			{
				let monster = Spawn(minionName[i], owner.pos);
				if (monster)
				{
					minions[i] = monster;
					monster.bFriendly = true;
					monster.master = owner;
					monster.health = minionHealth[i];
					monster.SetState(monster.SeeState);
					monster.A_SetRenderStyle(0.6, STYLE_Translucent);
				}
			}
		}
		
		for (uint i = 0; i < minionHealth.Size(); ++i)
		{
			if (minionHealth[i] <= 0)
			{
				minions.Delete(i);
				minionHealth.Delete(i);
				minionName.Delete(i);
				--i;
			}
		}
	}
	
	override void UseSkill()
	{
		let tracer = new("UndeadTracer");
		if (tracer)
		{
			Vector3 start = owner.pos + (0,0, owner.player.mo.viewheight - owner.floorclip);
			Vector3 dir = (AngleToVector(owner.angle, cos(owner.pitch)), -sin(owner.pitch));
			tracer.master = owner;
			tracer.Trace(start, CurSector, dir, 256, 0);
			
			if (tracer.results.hitActor)
			{
				if (!CheckAmmo(10, type, reserveType))
				{
					Console.Printf("You do not have enough resources to cast this");
					return;
				}
				
				bool gibbed = tracer.results.hitActor.health <= tracer.results.hitActor.GetGibHealth();
				if (tracer.results.hitActor.A_RaiseSelf(RF_NOCHECKPOSITION))
				{
					TakeAmmo(10, type, reserveType);
					
					if (gibbed)
					{
						let xraise = tracer.results.hitActor.FindState("XRaise");
						if (xraise)
							tracer.results.hitActor.SetState(xraise);
					}
					
					uint currentMinions;
					for (uint i = 0; i < minions.Size(); ++i)
					{
						if (minions[i])
							++currentMinions;
					}
					
					if (currentMinions >= MAX_MINIONS)
					{
						uint index;
						int minHealth = 0x7FFFFFFF;
						for (uint i = 0; i < minions.Size(); ++i)
						{
							if (minions[i] && minionHealth[i] < minHealth)
							{
								index = i;
								minHealth = minionHealth[i];
							}
						}
					
						if (minions[index])
							minions[index].DamageMobj(null, null, TELEFRAG_DAMAGE, "Telefrag");
						
						minions.Delete(index);
						minionHealth.Delete(index);
						minionName.Delete(index);
					}
					
					minions.Push(tracer.results.hitActor);
					minionName.Push(tracer.results.hitActor.GetClass());
					minionHealth.Push(tracer.results.hitActor.health);
					
					tracer.results.hitActor.master = owner;
					tracer.results.hitActor.bFriendly = true;
					tracer.results.hitActor.target = null;
					tracer.results.hitActor.A_SetRenderStyle(0.6, STYLE_Translucent);
				}
			}
			else
			{
				for (uint i = 0; i < minions.Size(); ++i)
				{
					if (minions[i])
					{
						minions[i].SetOrigin(owner.pos, false);
						minions[i].target = null;
					}
				}
			}
		}
	}
}

class Haste : Skill
{
	Default
	{
		Skill.BuffType "HasteBuff";
		Skill.Drain 1;
		Skill.DrainType "BlueMana";
		Skill.ReserveDrainType "RedMana";
		Inventory.Icon "MWNDC0";
		Tag "Haste";
		Skill.Description "Use mana to increase your projectiles' speed by 50%";
		
		+SKILL.TOGGLE
		+SKILL.SPECIALDRAIN
	}
	
	override void UseSkill()
	{
		GiveBuff(owner);
	}
	
	override void EndSkill()
	{
		TakeBuff();
	}
}

class HasteBuff : Buff
{
	Default
	{
		Inventory.Icon "MWNDC0";
		Buff.Cost 1;
		Buff.Type "BlueMana";
		Buff.ReserveType "RedMana";
		
		+BUFF.INFINITE
	}
	
	override void MissileFired(Actor missile)
	{
		if (!missile || missile.target != owner || missile.master)
			return;
		
		missile.speed *= 1.5;
		missile.vel *= 1.5;
		TakeAmmo(cost, type, reserveType);
	}
}

class IceExplosion : AreaOfEffect
{
	Default
	{
		Radius 256;
		Height 256;
		Damage 200;
		DamageType "Ice";
		AreaOfEffect.AilmentPower 100;
		AreaOfEffect.AilmentType "Chill";
		Threshold 1;
		
		+AREAOFEFFECT.SHATTERER
		+AREAOFEFFECT.FREEZER
	}
}

class IceNova : Skill
{
	Default
	{
		Skill.Cost 50;
		Skill.Type "BlueMana";
		Skill.ReserveType "RedMana";
		Skill.CoolDown 1050;
		Inventory.Icon "SHEXB0";
		Tag "Ice Nova";
		Skill.Description "Unleash a devasting blast of ice, chilling and freezing all enemies around you";
	}
	
	override void UseSkill()
	{
		let mo = Spawn("IceExplosion", owner.pos, ALLOW_REPLACE);
		if (mo)
		{
			mo.target = owner;
			mo.angle = owner.angle;
		}
	}
}

class Shadow : Skill
{
	Default
	{
		Skill.BuffType "ShadowBuff";
		Skill.Cost 10;
		Skill.Type "GreenMana";
		Skill.ReserveType "GreenMana";
		Skill.Drain 1;
		Skill.DrainType "GreenMana";
		Skill.ReserveDrainType "RedMana";
		Skill.DrainInterval 9;
		Inventory.Icon "SPIRA1";
		Tag "Shadow";
		Skill.Description "Become nearly invisible. Only nearby enemies will see and attempt to attack you";
		
		+SKILL.TOGGLE
	}
	
	override void UseSkill()
	{
		GiveBuff(owner);
	}
	
	override void EndSkill()
	{
		TakeBuff();
		owner.A_SetRenderStyle(1, STYLE_Normal);
		owner.bShadow = false;
	}
}

class ShadowBuff : Buff
{
	Default
	{
		Inventory.Icon "SPIRA1";
		
		+BUFF.INFINITE
	}
	
	override void Effect()
	{
		owner.bShadow = true;
		owner.A_SetRenderStyle(0.2, STYLE_Translucent);
	}
}

class Thunder : Skill
{
	Default
	{
		Skill.Cost 15;
		Skill.Type "RedMana";
		Inventory.Icon "MLFXI0";
		Tag "Thunder";
		Skill.Description "Fire a devasting bolt of lightning from your hand that chain reacts to nearby hit enemies";
	}
}