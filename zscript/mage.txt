class ReforgedMage : RPGPlayer
{
	Default
	{
		Radius 16;
		Height 64;
		PainSound "PlayerMagePain";
		Player.JumpZ 9;
		Player.Viewheight 48;
		Player.SpawnClass "Mage";
		Player.DisplayName "Mage";
		Player.SoundClass "mage";
		Player.ScoreIcon "MAGEFACE";
		Player.StartItem "ReforgedWand";
		Player.StartItem "AmuletPiece";
		Player.StartItem "BlueMana", 100;
		Player.StartItem "GreenMana", 100;
		Player.StartItem "RedMana", 0;
		Player.Portrait "P_MWALK1";
		Player.WeaponSlot 1, "ReforgedWand";
		Player.WeaponSlot 2, "ReforgedFrost";
		Player.WeaponSlot 3, "ReforgedLightning";
		Player.WeaponSlot 4, "MWeapBloodscourge";
		
		Player.ColorRange 146, 163;
		Player.Colorset		0, "$TXT_COLOR_BLUE",		146, 163,    161;
		Player.ColorsetFile 1, "$TXT_COLOR_RED",		"TRANTBL7",  0xB3;
		Player.ColorsetFile 2, "$TXT_COLOR_GOLD",		"TRANTBL8",  0x8C;
		Player.ColorsetFile 3, "$TXT_COLOR_DULLGREEN",	"TRANTBL9",  0x41;
		Player.ColorsetFile 4, "$TXT_COLOR_GREEN",		"TRANTBLA",  0xC9;
		Player.ColorsetFile 5, "$TXT_COLOR_GRAY",		"TRANTBLB",  0x30;
		Player.ColorsetFile 6, "$TXT_COLOR_BROWN",		"TRANTBLC",  0x72;
		Player.ColorsetFile 7, "$TXT_COLOR_PURPLE",		"TRANTBLD",  0xEE;
		
		+NOSKIN
	}

	States
	{
		Spawn:
			MAGE A -1;
			Stop;
			
		See:
			MAGE ABCD 4;
			Loop;
			
		Missile:
		Melee:
			MAGE EF 8;
			Goto Spawn;
			
		Pain:
			MAGE G 4;
			MAGE G 4 A_Pain;
			Goto Spawn;
			
		Death:
			MAGE H 6;
			MAGE I 6 A_PlayerScream;
			MAGE JK 6;
			MAGE L 6 A_NoBlocking;
			MAGE M 6;
			MAGE N -1;
			Stop;	
			
		XDeath:
			MAGE O 5 A_PlayerScream;
			MAGE P 5;
			MAGE R 5 A_NoBlocking;
			MAGE STUVW 5;
			MAGE X -1;
			Stop;
			
		Ice:
			MAGE Y 5 A_FreezeDeath;
			MAGE Y 1 A_FreezeDeathChunks;
			Wait;
			
		Burn:
			FDTH E 5 BRIGHT A_PlaySound("*burndeath");
			FDTH F 4 BRIGHT;
			FDTH G 5 BRIGHT;
			FDTH H 4 BRIGHT A_PlayerScream;
			FDTH I 5 BRIGHT;
			FDTH J 4 BRIGHT;
			FDTH K 5 BRIGHT;
			FDTH L 4 BRIGHT;
			FDTH M 5 BRIGHT;
			FDTH N 4 BRIGHT;
			FDTH O 5 BRIGHT;
			FDTH P 4 BRIGHT;
			FDTH Q 5 BRIGHT;
			FDTH R 4 BRIGHT;
			FDTH S 5 BRIGHT A_NoBlocking;
			FDTH T 4 BRIGHT;
			FDTH U 5 BRIGHT;
			FDTH V 4 BRIGHT;
			ACLO E 35 A_CheckPlayerDone;
			Wait;
			ACLO E 8;
			Stop;
	}
	
	override void InitializeSkills()
	{
		SetSkill(0, "Desecrate", true);
		SetSkill(1, "RaiseDead", true);
		SetSkill(2, "IceBomb", true);
		
		SetActiveSkill(0, "Desecrate");
		SetActiveSkill(1, "RaiseDead");
		SetActiveSkill(2, "IceBomb");
	}
	
	override void InitializeStats()
	{
		super.InitializeStats();
		
		let wis = Stat(FindInventory("Wisdom"));
		if (wis)
			wis.LevelUp(2, true);
		
		let intel = Stat(FindInventory("Intelligence"));
		if (intel)
			intel.LevelUp(2, true);
	}
}

class UndeadTracer : LineTracer
{
	Actor master;
	
	override ETraceStatus TraceCallback()
	{
		switch (results.HitType)
		{
			case TRACE_HitWall:
				int blockFlags = Line.ML_BLOCKEVERYTHING;
				if (!(results.hitLine.flags & blockFlags) &&
					(results.hitLine.flags & Line.ML_TWOSIDED) &&
					results.tier == TIER_Middle)
				{
					results.hitType = TRACE_HitNone;
					break;
				}
			case TRACE_HasHitSky:
			case TRACE_HitFloor:
			case TRACE_HitCeiling:
				return TRACE_Stop;
				break;
			
			case TRACE_HitActor:
				if (results.hitActor != master && !results.hitActor.bFriendly &&
					results.hitActor.bIsMonster && results.hitActor.health <= 0 &&
					results.hitActor.tics == -1)
				{
					return TRACE_Stop;
				}
				results.hitType = TRACE_HitNone;
				results.hitActor = null;
				break;
		}
		
		return TRACE_Skip;
	}
}

class Desecrate : Skill
{
	Default
	{
		Skill.Type "GreenMana";
		Skill.ReserveType "RedMana";
		Inventory.Icon "PTN1A0";
	}
	
	override void UseSkill()
	{
		if (!CheckAmmo(5, type, reserveType))
		{
			Console.Printf("You do not have enough resources to cast this");
			return;
		}
				
		let tracer = new("UndeadTracer");
		if (tracer)
		{
			Vector3 start = owner.pos + (0,0, owner.player.mo.viewheight - owner.floorclip);
			Vector3 dir = (AngleToVector(owner.angle, cos(owner.pitch)), -sin(owner.pitch));
			tracer.master = owner;
			tracer.Trace(start, CurSector, dir, 256, 0);
			
			if (tracer.results.hitActor)
			{
				TakeAmmo(5, type, reserveType);
				let mo = Spawn("CrystalVial", tracer.results.hitActor.pos, ALLOW_REPLACE);
				if (mo && !mo.bNoGravity)
					mo.vel.z += 7;
				
				tracer.results.hitActor.Destroy();
			}
		}
	}
}

class RaiseDead : Skill
{
	const MAX_MINIONS = 5;
	
	Array<Actor> minions;
	
	Array<class<Actor> > minionName;
	Array<int> minionHealth;
	
	int prevLevelNum;
	
	Default
	{
		Skill.Type "BlueMana";
		Skill.ReserveType "RedMana";
		Inventory.Icon "MAN3A0";
	}
	
	override void ModifyDamage(int damage, Name damageType, out int newdamage, bool passive, Actor inflictor, Actor source, int flags)
	{
		if (passive)
		{
			if (source && damage > 0 && source.bIsMonster && !source.bFriendly)
			{
				for (uint i = 0; i < minions.Size(); ++i)
				{
					if (minions[i] && !minions[i].target)
						minions[i].target = source;
				}
			}
		}
	}
	
	override void Tick()
	{
		super.Tick();
		
		if (!prevLevelNum)
			prevLevelNum = level.levelNum;
		
		if (level.levelNum != prevLevelNum)
		{
			ThinkerIterator it = ThinkerIterator.Create("Actor", STAT_DEFAULT);
			Actor mo;
			
			while (mo = Actor(it.Next()))
			{
				if (mo && mo.bIsMonster && mo.master == owner && minions.Find(mo) == minions.Size())
					mo.Destroy();
			}
		}
		
		prevLevelNum = level.levelNum;
		
		for (uint i = 0; i < minions.Size(); ++i)
		{
			if (minions[i])
				minionHealth[i] = minions[i].health;
			else
			{
				let monster = Spawn(minionName[i], owner.pos);
				if (monster)
				{
					minions[i] = monster;
					monster.bFriendly = true;
					monster.master = owner;
					monster.health = minionHealth[i];
					monster.SetState(monster.SeeState);
					monster.A_SetRenderStyle(0.6, STYLE_Translucent);
				}
			}
		}
		
		for (uint i = 0; i < minionHealth.Size(); ++i)
		{
			if (minionHealth[i] <= 0)
			{
				minions.Delete(i);
				minionHealth.Delete(i);
				minionName.Delete(i);
				--i;
			}
		}
	}
	
	override void UseSkill()
	{
		let tracer = new("UndeadTracer");
		if (tracer)
		{
			Vector3 start = owner.pos + (0,0, owner.player.mo.viewheight - owner.floorclip);
			Vector3 dir = (AngleToVector(owner.angle, cos(owner.pitch)), -sin(owner.pitch));
			tracer.master = owner;
			tracer.Trace(start, CurSector, dir, 256, 0);
			
			if (tracer.results.hitActor)
			{
				if (!CheckAmmo(10, type, reserveType))
				{
					Console.Printf("You do not have enough resources to cast this");
					return;
				}
				
				bool gibbed = tracer.results.hitActor.health <= tracer.results.hitActor.GetGibHealth();
				if (tracer.results.hitActor.A_RaiseSelf())
				{
					TakeAmmo(10, type, reserveType);
					
					if (gibbed)
					{
						let xraise = tracer.results.hitActor.FindState("XRaise");
						if (xraise)
							tracer.results.hitActor.SetState(xraise);
					}
					
					uint currentMinions;
					for (uint i = 0; i < minions.Size(); ++i)
					{
						if (minions[i])
							++currentMinions;
					}
					
					if (currentMinions >= MAX_MINIONS)
					{
						uint index;
						int minHealth = 0x7FFFFFFF;
						for (uint i = 0; i < minions.Size(); ++i)
						{
							if (minions[i] && minionHealth[i] < minHealth)
							{
								index = i;
								minHealth = minionHealth[i];
							}
						}
					
						if (minions[index])
							minions[index].DamageMobj(null, null, TELEFRAG_DAMAGE, "Telefrag");
						
						minions.Delete(index);
						minionHealth.Delete(index);
						minionName.Delete(index);
					}
					
					minions.Push(tracer.results.hitActor);
					minionName.Push(tracer.results.hitActor.GetClass());
					minionHealth.Push(tracer.results.hitActor.health);
					
					tracer.results.hitActor.master = owner;
					tracer.results.hitActor.bFriendly = true;
					tracer.results.hitActor.target = null;
					tracer.results.hitActor.A_SetRenderStyle(0.6, STYLE_Translucent);
				}
			}
			else
			{
				for (uint i = 0; i < minions.Size(); ++i)
				{
					if (minions[i])
					{
						minions[i].SetOrigin(owner.pos, false);
						minions[i].target = null;
					}
				}
			}
		}
	}
}

class IceExplosion : RPGMissile
{
	Default
	{
		Radius 256;
		Damage 200;
		DamageType "Ice";
		RPGMissile.AilmentPower 100;
		RPGMissile.AilmentType "Chill";
		
		+RPGMISSILE.FREEZER
		+ICESHATTER
	}
	
	States
	{
		Spawn:
		Death:
			TNT1 A 1 A_Explode(damage, radius, 0, false, radius, damagetype: damageType);
			Stop;
	}
}

class IceBomb : Skill
{
	Default
	{
		Skill.Cost 50;
		Skill.Type "BlueMana";
		Skill.CoolDown 1050;
		Inventory.Icon "SHEXB0";
	}
	
	override void UseSkill()
	{
		let missile = Spawn("IceExplosion", owner.pos, ALLOW_REPLACE);
		if (missile)
		{
			missile.target = owner;
			missile.ExplodeMissile();
		}
	}
}