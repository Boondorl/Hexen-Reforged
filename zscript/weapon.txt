enum EExtendedDmgFlags
{
	DMG_CRIT = 1<<20, // Leave room just in case
	DMG_NOBLOCK = 1<<21
}

class RPGWeapon : Weapon
{
	bool bBash;
	
	int bashCost;
	
	property BashCost : bashCost;
	
	action void A_BashWeaponReady(int flags = 0)
	{
		flags |= WRF_ALLOWUSER1;
		if (player.cmd.buttons & BT_USER1)
		{
			invoker.bBash = true;
			if (!invoker.DepleteAmmo(false, true, 1))
				flags &= ~WRF_ALLOWUSER1;
			invoker.bBash = false;
		}
		
		A_WeaponReady(flags);
	}

	action void A_WandBlast(int dmg, Name dmgType = 'None', int blastflags = 0, double rad = 128, double speed = 15, double maxAng = 35, sound blastsound = "BlastRadius")
	{
		A_PlaySound(blastsound, CHAN_AUTO);

		if (!(blastflags & BF_DONTWARN))
			SoundAlert(self);
		
		Vector3 viewDir = (AngleToVector(angle, cos(pitch)), -sin(pitch));
		
		ThinkerIterator it = ThinkerIterator.Create("Actor", STAT_DEFAULT);
		Actor mo;
		while (mo = Actor(it.Next()))
		{
			if (mo == self || (mo.bBoss && !(blastflags & BF_AFFECTBOSSES)) || mo.bDormant || !(mo.bIsMonster || mo.player) || IsFriend(mo))
				continue;
			
			if (mo.bIceCorpse)
			{
				mo.DamageMobj(self, self, 1, 'None');
				continue;
			}
			else if (mo.health <= 0)
				continue;
			
			if (Distance3DSquared(mo) > (radius + rad + mo.radius)**2)
				continue;
			
			if (!CheckSight(mo))
				continue;
			
			Vector3 dir = (Vec3To(mo) + (0,0,mo.height/2 - height*3/4.)).Unit();
			if (acos(dir dot viewDir) > maxAng)
				continue;
			
			mo.DamageMobj(self, self, dmg, dmgType, DMG_NOBLOCK);
			let ail = Ailment(mo.FindInventory("Stumble"));
			if (ail)
				ail.AddAilment(self, 100);
			else
				mo.vel += dir * speed;
		}
	}
	
	action void A_Melee(class<HurtBox> box, int dmg = -1, int bdmg = -1, double dur = 1, double range = 64, double minAng = 0, double maxAng = 0, double minPch = 0, double maxPch = 0, double minRol = 0, double maxRol = 0, double minForw = 0, double maxForw = 0)
	{
		if (!box)
			return;
		
		let hb = HurtBox(Spawn(box, pos, ALLOW_REPLACE));
		if (hb)
		{
			hb.target = self;
			hb.duration = dur;
			hb.range = range;
			if (dmg >= 0)
				hb.SetDamage(dmg);
			if (bdmg >= 0)
				hb.bonusDamage = bdmg;
			
			hb.angleRange.Push(minAng);
			hb.angleRange.Push(maxAng);
			hb.pitchRange.Push(minPch);
			hb.pitchRange.Push(maxPch);
			hb.rollRange.Push(minRol);
			hb.rollRange.Push(maxRol);
			hb.forwardOffsets.Push(minForw);
			hb.forwardOffsets.Push(maxForw);
		}
	}
	
	override bool CheckAmmo(int fireMode, bool autoSwitch, bool requireAmmo, int ammocount)
	{
		int count1, count2;

		if (sv_infiniteammo || owner.FindInventory('PowerInfiniteAmmo'))
			return true;
		
		if (fireMode == EitherFire)
		{
			bool gotSome = CheckAmmo(PrimaryFire, false) || CheckAmmo(AltFire, false);
			if (!gotSome)
			{
				bBash = true;
				gotSome = CheckAmmo(PrimaryFire, false);
				bBash = false;
			}
			
			if (!gotSome && autoSwitch)
				PlayerPawn(owner).PickNewWeapon(null);
			
			return gotSome;
		}
		
		let altFire = (fireMode == AltFire);
		let optional = (altFire ? bAlt_Ammo_Optional : bAmmo_Optional);

		if (!bBash && !requireAmmo && optional)
			return true;
		
		int use = altFire ? AmmoUse2 : AmmoUse1;
		
		count1 = Ammo1 ? Ammo1.Amount : 0;
		count2 = Ammo2 ? Ammo2.Amount : 0;

		if (bBash)
		{
			if (count1 + count2 >= bashCost)
				return true;
		}
		else if (count1 + count2 >= use)
			return true;
		
		// out of ammo, pick a weapon to change to
		if (autoSwitch)
			PlayerPawn(owner).PickNewWeapon(null);
		
		return false;
	}
	
	override bool DepleteAmmo(bool altFire, bool checkEnough, int ammouse)
	{
		if (sv_infiniteammo || owner.FindInventory('PowerInfiniteAmmo'))
			return true;
		
		if (checkEnough && !CheckAmmo(altFire ? AltFire : PrimaryFire, false, true, ammouse))
			return false;
		
		if (bBash)
		{
			if (Ammo1)
			{
				int use = bashCost > Ammo1.Amount ? bashCost - Ammo1.Amount : 0;
				Ammo1.Amount -= bashCost;
				if (Ammo2)
					Ammo2.Amount -= use;
			}
		}
		else if (!altFire)
		{
			if (Ammo1)
			{
				int use = AmmoUse1 > Ammo1.Amount ? AmmoUse1 - Ammo1.Amount : 0;
				Ammo1.Amount -= AmmoUse1;
				if (Ammo2)
					Ammo2.Amount -= use;
			}
		}
		else
		{
			if (Ammo1)
			{
				int use = AmmoUse2 > Ammo1.Amount ? AmmoUse2 - Ammo1.Amount : 0;
				Ammo1.Amount -= AmmoUse2;
				if (Ammo2)
					Ammo2.Amount -= use;
			}
		}
		
		if (Ammo1 && Ammo1.Amount < 0)
			Ammo1.Amount = 0;
		if (Ammo2 && Ammo2.Amount < 0)
			Ammo2.Amount = 0;
			
		return true;
	}
}

class CastWeapon : RPGWeapon
{
	Weapon prevWeapon;
}

class AreaOfEffect : Actor
{
	double ailmentPower;
	class<Ailment> ailmentType;
	int ailmentDamage;
	class<CoolDownToken> coolDownToken;
	
	property AilmentPower : ailmentPower;
	property AilmentType : ailmentType;
	property AilmentDamage : ailmentDamage;
	property CoolDownToken : coolDownToken;
	
	deprecated("3.7") private int areaOfEffectFlags;
	flagdef Blocker: areaOfEffectFlags, 0;
	flagdef Shatterer: areaOfEffectFlags, 1;
	flagdef Grounded: areaOfEffectFlags, 2;
	flagdef Spherical: areaOfEffectFlags, 3;
	flagdef DamageOwner: areaOfEffectFlags, 4;
	
	Default
	{
		+NODAMAGETHRUST
		+NOBLOCKMAP
		+DROPOFF
	}
	
	virtual void Effect() {}
	
	override void Tick()
	{
		super.Tick();
		
		if (threshold > 0)
		{
			if (--threshold <= 0)
			{
				State death = FindState("Death");
				if (death)
					SetState(death);
				else
					Destroy();
			}
			else
			{
				Effect();
				BlockThingsIterator it = BlockThingsIterator.Create(self);
				Actor mo;
				while (it.Next())
				{
					mo = it.thing;
					if (!mo || (!bDamageOwner && (mo == target || mo.IsFriend(target))) || !mo.bShootable || !(mo.bIsMonster || mo.player) || (!mo.bIceCorpse && mo.health <= 0))
						continue;
					
					bool distanceCheck;
					if (bSpherical)
						distanceCheck = Distance3DSquared(mo) <= (radius+mo.radius)**2;
					else
					{
						distanceCheck = Distance2DSquared(mo) <= (radius+mo.radius)**2;
						if (distanceCheck)
						{
							if (bGrounded)
								distanceCheck = mo.pos.z <= mo.floorz + height && abs(mo.floorz - pos.z) <= MaxStepHeight;
							else
								distanceCheck = mo.pos.z <= pos.z+height && mo.pos.z+mo.height >= pos.z;
						}
					}
					
					height = target.height;
					if (distanceCheck && CheckSight(mo))
					{
						if (mo.bIceCorpse)
						{
							if (bShatterer)
								mo.DamageMobj(self, target, 1, 'None');
						}
						else if (!mo.FindInventory(coolDownToken))
						{
							mo.DamageMobj(self, target, damage, damageType, bBlocker ? 0 : DMG_NOBLOCK);
							mo.GiveInventoryType(coolDownToken);
							let ail = Ailment(mo.FindInventory(ailmentType));
							if (ail)
								ail.AddAilment(target, ailmentPower, ailmentDamage);
						}
					}
					height = default.height;
				}
			}
		}
	}
}

class CoolDownToken : Inventory
{
	Default
	{
		+INVENTORY.UNDROPPABLE
	}
	
	override void Tick()
	{
		super.Tick();
		
		if (threshold-- <= 0)
			Destroy();
	}
}

class FlechetteMissile : RPGMissile
{
	Default
	{
		Speed 24;
		Radius 3;
		Height 6;
		DamageType "Poison";
		RPGMissile.AilmentType "Poison";
		RPGMissile.AilmentPower 100;
		RPGMissile.AilmentDamage 5;
		DeathSound "FlechetteExplode";
		
		+RPGMISSILE.NOBLOCKWARN
		-NOGRAVITY
	}
	
	States
	{
		Spawn:
			THRW A 4;
			THRW BCDE 3;
			THRW F 3;
			Loop;

		Death:
			PSBG B 4 Bright A_Explode(20, 64, XF_HURTSOURCE, false, 64);
			PSBG C 3;
			PSBG C 1 A_PoisonBagInit;
			Stop;
	}

	void A_PoisonBagInit()
	{
		Actor mo = Spawn("RPoisonCloud", pos+(0,0,32), ALLOW_REPLACE);
		if (mo)
			mo.target = target;
	}
}

class RPoisonCloud : AreaOfEffect
{
	Default
	{
		AreaOfEffect.AilmentPower 15;
		AreaOfEffect.AilmentType "Poison";
		AreaOfEffect.AilmentDamage 3;
		AreaOfEffect.CoolDownToken "PoisonCloudHit";
		Radius 64;
		Height 32;
		Damage 3;
		DamageType "Poison";
		RenderStyle "Translucent";
		Alpha 0.5;
		Threshold 350;
		DeathSound "PoisonShroomDeath";
		
		+AREAOFEFFECT.DAMAGEOWNER;
	}

	States
	{
		Spawn:
			PSBG D 1;
			PSBG D 1 A_Scream;
			PSBG DEEEFFFGGGHHHIII 2;
			Goto Spawn + 3;
			
		Death:
			PSBG HG 7;
			PSBG FD 6;
			Stop;
	}
}

class PoisonCloudHit : CoolDownToken
{
	Default
	{
		Threshold 3;
	}
}

class BanishmentMissile : FastProjectile
{
	Default
	{
		Speed 64;
		Radius 4;
		Height 2;
		Threshold 16;
		
		-ACTIVATEIMPACT
		-ACTIVATEPCROSS
		+BLOODLESSIMPACT
	}
	
	States
	{
		Spawn:
			TNT1 A 4;
			Stop;
			
		Death:
			TNT1 A 0;
			Stop;
	}
	
	override void Tick()
	{
		super.Tick();
		
		if (globalfreeze || level.frozen)
			return;
		
		if (radius < threshold)
			A_SetSize(radius+3, height);
	}
	
	override int SpecialMissileHit(Actor victim)
	{
		if (victim == target || (target && target.IsFriend(victim)))
			return 1;
		
		if (!victim.bShootable || victim.health <= 0 || !(victim.bIsMonster || victim.player) || victim.bBoss)
			return 1;
		
		if (master)
		{
			victim.Teleport((master.pos.xy, master.floorz), victim.angle, TELF_SOURCEFOG | TELF_DESTFOG);
			victim.DamageMObj(null, null, TELEFRAG_DAMAGE, "Telefrag");
		}
		
		return 1;
	}
}

class TelOtherRFX1 : Actor
{
	Default
	{
		Projectile;
		Radius 4;
		Height 8;
		Speed 24;
		
		-ACTIVATEIMPACT
		-ACTIVATEPCROSS
		+BLOODLESSIMPACT
	}


	States
	{
		Spawn:
			TRNG E 5 Bright;
			TRNG D 4 Bright;
			TRNG C 3 Bright;
			TRNG B 3 Bright;
			TRNG A 3 Bright;
			TRNG B 3 Bright;
			TRNG C 3 Bright;
			TRNG D 3 Bright;
			Goto Spawn+2;
			
		Crash:
		XDeath:
			TRNG E 3 Bright;
			Stop;
			
		Death:
			TRNG E 3 Bright
			{
				let frag = Spawn("TelefragDestination", pos);
				if (frag)
				{
					for (int i = 0; i < 24; ++i)
					{
						let missile = Spawn("BanishmentMissile", pos, ALLOW_REPLACE);
						if (missile)
						{
							missile.master = frag;
							missile.target = target;
							missile.angle = i*15;
							missile.VelFromAngle();
						}
					}
				}
			}
			Stop;
	}
		
	override int SpecialMissileHit(Actor victim)
	{
		if (victim == target || (target && target.IsFriend(victim)))
			return 1;
		
		if (victim.health <= 0 || (victim.bShootable && !(victim.bIsMonster || victim.player)))
			return 1;
		
		let frag = Spawn("TelefragDestination", pos);
		if (frag)
		{
			for (int i = 0; i < 24; ++i)
			{
				let missile = Spawn("BanishmentMissile", pos, ALLOW_REPLACE);
				if (missile)
				{
					missile.master = frag;
					missile.target = target;
					missile.angle = i*15;
					missile.VelFromAngle();
				}
			}
		}
		
		return -1;
	}
}

class TelefragDestination : Actor
{
	Default
	{
		+NOINTERACTION
	}
	
	States
	{
		Spawn:
			TNT1 A 8;
			Stop;
	}
}