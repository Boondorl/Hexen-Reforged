class ReforgedClink : RPGMonster
{
	private Vector3 oldPos;
	
	Default
	{
		RPGMonster.MinMissileCoolDown 175;
		RPGMonster.MaxMissileCoolDown 245;
		RPGMonster.XP 60;
		Health 200;
		Radius 20;
		Height 64;
		DeathHeight 32;
		Mass 200;
		Speed 4;
		Damage 75;
		Painchance 32;
		MaxTargetRange 192;
		SeeSound "clink/sight";
		AttackSound "clink/attack";
		PainSound "clink/pain";
		DeathSound "clink/death";
		ActiveSound "clink/active";
		Obituary "$OB_CLINK";
		Tag "$FN_CLINK";
		
		+NOBLOOD
		+RPGMONSTER.BLOCKER
		+RPGMONSTER.JUMPER
		-NOICEDEATH
	}
	
	States
	{
		Spawn:
			CLNK AABB 5 A_MonsterLook;
			Loop;
			
		See:
			CLNK ABCD 3 A_SabreChase;
			Loop;
			
		Missile:
			TNT1 A 0 A_PlaySound(AttackSound, CHAN_VOICE);
			CLNK E 6 A_MonsterFaceTarget;
			CLNK F 2 A_MonsterFaceTarget;
			CLNK F 2 {vel.z += 6;}
			CLNK F 1
			{
				oldPos = pos;
				A_SkullAttack(15);
				vel.z += 5;
			}
			CLNK F 1
			{
				if (OnGround() || pos == oldPos)
				{
					bSkullFly = false;
					vel = (0,0,0);
					SetState(FindState("Land"));
				}

				oldPos = pos;
			}
			Goto Missile+5;
			
		Land:
			CLNK G 8;
			Goto See;
			
		Melee:
			CLNK E 5 A_MonsterFaceTarget;
			CLNK F 4 A_MonsterFaceTarget;
			CLNK G 7;// A_ReforgedMeleeAttack(10, "clink/attack", "clink/attack");
			Goto See;
			
		Stumble:
			CLNK H 3;
			CLNK H 3 A_Pain;
			Goto See;
			
		Death:
			CLNK IJ 6;
			CLNK K 5 A_Scream;
			CLNK L 5 A_NoBlocking;
			CLNK MN 5;
			CLNK O -1;
			Stop;
			
		Raise:
			CLNK NMLK 5;
			CLNK JI 6;
			Goto See;
	}
	
	override bool Slam(Actor victim)
	{
		if (!victim.bSolid)
			return true;
			
		bSkullFly = false;
		vel = (0,0,0);
		
		if (health > 0)
		{
			if (!bDormant)
			{
				if (!victim.bGhost)
				{
					int newdam = victim.DamageMobj(self, self, 30, 'Cleave');
					victim.TraceBleed(newdam > 0 ? newdam : damage, self);
				}
				
				if (health > 0)
				{
					State land = FindState("Land");
					if (land)
						SetState(land);
					else if (SeeState)
						SetState(SeeState);
					else
						SetIdle();
				}
			}
			else
			{
				SetIdle();
				tics = -1;
			}
		}
		
		return false; 
	}
	
	void A_SabreChase()
	{
		if (target && OnGround())
		{
			double distance = Distance3D(target) - target.radius;
			if (distance <= MaxTargetRange && distance > MeleeRange*2 && (target.pos.z - pos.z) <= 64)
			{
				FLineTraceData t;
				LineTrace(0, 96, -90, TRF_THRUHITSCAN | TRF_ALLACTORS | TRF_SOLIDACTORS, 0, 0, 0, t); // Check to make sure there's enough head room
				if (t.Distance >= 96)
				{
					A_MonsterChase();
					return;
				}
			}
		}
			
		A_MonsterChase("Melee", null);
	}
	
	override bool CheckMissile()
	{
		if (target && missileCoolDown <= 0 && Distance3DSquared(target) <= random(0, MaxTargetRange**2))
		{
			let tracer = SightTracer(new("SightTracer"));
			if (tracer)
			{
				tracer.master = self;
				tracer.target = target;
				tracer.bThruObj = bAttackThruObj;
				tracer.bThruMonst = bAttackThruMonst;
				
				double h = missileCheckHeight ? missileCheckHeight : height/2 + 4;
				h -= floorclip;
				Vector3 start = pos + (0,0,h);
				Vector3 dir = Vec3To(target) + (0,0,(target.height/2-target.floorclip) - h);
				
				tracer.Trace(start, CurSector, dir.Unit(), dir.Length(), 0);
				if (tracer.results.hitType == TRACE_HitNone || tracer.results.hitActor == target)
				{
					missileCoolDown = random(minMissileCoolDown, maxMissileCoolDown);
					return true;
				}
			}
		}
		
		return false;
	}
	
	override void InitializeAilments()
	{
		SetAilment(0, 'Stumble');
	}
	
	override void BeginPlay()
	{
		super.BeginPlay();
		
		CreateBox("SabreBody");
		CreateBox("SabreHead");
	}
}

class SabreBody : CollisionBox
{
	Default
	{
		Radius 20;
		Height 50;
	}
}

class SabreHead : CollisionBox
{
	Default
	{
		CollisionBox.Multi 1.5;
		CollisionBox.ForwardOffset 10;
		CollisionBox.UpOffset 50;
		Radius 10;
		Height 14;
		
		+COLLISIONBOX.CRITICALZONE
	}
}