enum EMouseInput
{
	MI_LEFTPRESS = 1,
	MI_RIGHTPRESS,
	MI_LEFTRELEASE,
	MI_RIGHTRELEASE,
	MI_LEFTHOLD,
	MI_RIGHTHOLD
}

enum EButtonInput
{
	BI_USE = 1,
	BI_UP,
	BI_DOWN,
	BI_LEFT,
	BI_RIGHT,
	BI_SELECT,
	BI_CLOSE
}

enum EMenuState
{
	MS_CLOSED,
	MS_INV,
	MS_STAT
}

class MenuHandler : EventHandler
{
	transient ui RPGPlayer player;
	transient ui Array<Inventory> items;
	transient ui Array<Inventory> keyItems;
	transient ui Array<Skill> skills;
	transient ui Array<Stat> stats;
	transient ui Array<Inventory> keys;
	
	transient ui TextureID cursor;
	transient ui Array<MenuElement> elements;
	transient ui Array<MenuElement> navigable;
	transient ui Array<TextBox> textBoxes; // These get special handling since they should always be draw on top of everything
	
	transient ui Vector2 mouse;
	transient ui int mouseAction;
	transient ui int oldMouseAction;
	transient ui int buttonAction;
	transient ui int oldButtonAction;
	
	transient ui bool bInitialized;
	transient ui int menuState;
	transient ui int oldMenuState;
	
	transient ui int totalCost;
	transient ui int oldPoints;
	
	ui void LevelPlayer()
	{
		if (!player)
			return;
		
		if (player.currentPoints == player.points && totalCost <= 0)
			return;
		
		if (player.currentXP < totalCost)
			return;
		
		string command = "levelup";
		
		for (uint i = 0; i < stats.Size(); ++i)
		{
			if (stats[i].currentLevel == stats[i].level)
				continue;
			
			stats[i].currentCost = 0;
			command.AppendFormat(":%s:%d", stats[i].GetClassName(), stats[i].currentLevel);
		}
		
		oldPoints = player.currentPoints;
		EventHandler.SendNetworkEvent(command, totalCost, player.currentPoints);
	}
	
	// Sets the menu element nearest to the origin element
	ui void UpdateCollision(MenuElement origin)
	{
		if (!origin)
			return;
		
		for (uint i = 0; i < elements.Size(); ++i)
		{
			let probe = elements[i];
			if (probe && probe != origin)
				probe.CheckCollision(origin);
		}
	}
	
	override void UITick()
	{
		let mo = players[consoleplayer].mo;
		
		// Remove items from UI that should no longer show up
		for (uint i = 0; i < items.Size(); ++i)
		{
			if (!items[i] || items[i].owner != mo)
				items.Delete(i--);
		}
		
		for (uint i = 0; i < keyItems.Size(); ++i)
		{
			if (!keyItems[i] || keyItems[i].owner != mo)
				keyItems.Delete(i--);
		}
		
		for (uint i = 0; i < keys.Size(); ++i)
		{
			if (!keys[i] || keys[i].owner != mo)
				keys.Delete(i--);
		}
		
		// Update items
		for (let probe = mo.inv; probe; probe = probe.inv)
		{
			if (!probe || probe.amount <= 0)
				continue;
			
			if (probe is "PuzzleItem" && keyItems.Find(probe) == keyItems.Size())
				keyItems.Push(probe);
			else if (probe is "Key" && keys.Find(probe) == keys.Size())
				keys.Push(probe);
			else if (probe.bInvBar && items.Find(probe) == items.Size())
				items.Push(probe);
		}
		
		player = RPGPlayer(players[consoleplayer].mo);
		
		// Update stats and skills
		if (player)
		{
			for (uint i = 0; i < player.skills.Size(); ++i)
			{
				if (player.skills[i] && skills.Find(player.skills[i]) == skills.Size())
					skills.Push(player.skills[i]);
			}
			
			for (uint i = 0; i < player.stats.Size(); ++i)
			{
				if (player.stats[i] && stats.Find(player.stats[i]) == stats.Size())
					stats.Push(player.stats[i]);
			}
			
			if (oldPoints < 0)
				oldPoints = 0;
			
			if (menuState != MS_STAT || player.points != oldPoints)
				player.currentPoints += player.points - oldPoints;
			
			oldPoints = player.points;
		}
		
		// Tick elements
		for (uint i = 0; i < elements.Size(); ++i)
		{
			if (elements[i])
				elements[i].Tick();
		}
		
		for (uint i = 0; i < textBoxes.Size(); ++i)
		{
			if (textBoxes[i])
				textBoxes[i].Tick();
		}
	}
	
	ui void ClearUI()
	{
		for (uint i = 0; i < elements.Size(); ++i)
		{
			if (elements[i])
				elements[i].Destroy();
		}
		elements.Clear();
		
		for (uint i = 0; i < textBoxes.Size(); ++i)
		{
			if (textBoxes[i])
				textBoxes[i--].Destroy();
		}
		textBoxes.Clear();
		
		mouseAction = oldMouseAction = 0;
		buttonAction = oldButtonAction = 0;
	}
	
	override void RenderOverlay(RenderEvent e)
	{
		int wOfs, hOfs, w, h;
		[wOfs, hOfs, w, h] = Screen.GetViewWindow();
		
		if (player)
		{
			player.hideElements = 0;
			if (menuState == MS_INV)
				player.hideElements |= (EL_ITEMS | EL_SKILLS);
			
			if (player.hideElements & EL_ITEMS)
				players[consoleplayer].inventorytics = 0;
		}
		
		if (!bInitialized)
		{
			mouse.x = wOfs + w/2;
			mouse.y = hOfs + h/2;
			
			cursor = TexMan.CheckForTexture("CURSOR", TexMan.Type_Any);
			
			bInitialized = true;
		}
		
		mouse.x = clamp(mouse.x, wOfs, wOfs+w);
		mouse.y = clamp(mouse.y, hOfs, hOfs+h);
		
		if (!menuState && oldMenuState)
			ClearUI();
		
		if (menuState)
		{
			if (mouseAction == oldMouseAction)
			{
				switch (mouseAction)
				{
					case MI_LEFTPRESS:
						mouseAction = MI_LEFTHOLD;
						break;
									
					case MI_RIGHTPRESS:
						mouseAction = MI_RIGHTHOLD;
						break;
									
					case MI_LEFTHOLD:
					case MI_RIGHTHOLD:
						break;
							
					case MI_LEFTRELEASE:
					case MI_RIGHTRELEASE:
						mouseAction = 0;
						break;
				}
			}
			
			if (buttonAction == oldButtonAction)
				buttonAction = 0;
			
			if (menuState == MS_INV)
				DrawInventory();
			else if (menuState == MS_STAT)
				DrawStats();
			
			for (uint i = 0; i < elements.Size(); ++i)
			{
				if (elements[i])
					elements[i].Execute(e.fracTic);
			}
			
			for (uint i = 0; i < textBoxes.Size(); ++i)
			{
				if (textBoxes[i])
					textBoxes[i].Execute(e.fracTic);
			}
				
			Screen.DrawTexture(cursor, false, mouse.x, mouse.y, DTA_TopOffset, 0, DTA_LeftOffset, 0);
			
			oldMouseAction = mouseAction;
			oldButtonAction = buttonAction;
		}
		
		oldMenuState = menuState;
	}
	
	ui void DrawInventory()
	{
		if (oldMenuState != MS_INV)
		{
			ClearUI();
		
			DrawArmor();
			DrawItems();
			DrawKeyItems();
			DrawKeys();
			DrawPieces();
			DrawSkills();
		}
	}
	
	ui void DrawArmor()
	{
		let head = ArmorBox(MenuElement.Create("ArmorBox", self, (1425, 150), (100, 100)));
		if (head)
		{
			head.type = ArmorBox.AT_HEAD;
			elements.Push(head);
		}
			
		let amul = ArmorBox(MenuElement.Create("ArmorBox", self, (1525, 150), (100, 100)));
		if (amul)
		{
			amul.type = ArmorBox.AT_AMUL;
			elements.Push(amul);
		}
		
		let chest = ArmorBox(MenuElement.Create("ArmorBox", self, (1425, 250), (100, 100)));
		if (chest)
		{
			chest.type = ArmorBox.AT_CHEST;
			elements.Push(chest);
		}
		
		let brace = ArmorBox(MenuElement.Create("ArmorBox", self, (1525, 250), (100, 100)));
		if (brace)
		{
			brace.type = ArmorBox.AT_BRACE;
			elements.Push(brace);
		}
		
		let shield = ArmorBox(MenuElement.Create("ArmorBox", self, (1325, 250), (100, 100)));
		if (shield)
		{
			shield.type = ArmorBox.AT_SHIELD;
			elements.Push(shield);
		}
	}
	
	ui void DrawItems()
	{
		let can = MenuElement.Create("ItemCanvas", self, (650,300), (1100,400));
		if (can)
			elements.Push(can);
	}
	
	ui void DrawKeyItems()
	{
		let can = MenuElement.Create("KeyItemCanvas", self, (650,775), (1100,500));
		if (can)
			elements.Push(can);
	}
	
	ui void DrawSkills()
	{
		if (!player)
			return;
		
		int wOfs = 1375;
		for (uint i = 0; i < player.skillSlots; ++i)
		{
			let sk = SkillBox(MenuElement.Create("SkillBox", self, (wOfs,975), (100,100)));
			if (sk)
			{
				sk.slot = i;
				elements.Push(sk);
			}
			
			wOfs += 100;
		}
	}
	
	ui void DrawKeys()
	{
		let can = MenuElement.Create("KeyCanvas", self, (1547,456), (545,87));
		if (can)
			elements.Push(can);
	}
	
	ui void DrawPieces()
	{
		if (!player)
			return;
		
		let can = WeaponPieceCanvas(MenuElement.Create("WeaponPieceCanvas", self, (1734,196), (171,108)));
		if (can)
		{
			if (player is "ReforgedMage")
				can.SetWeapon(WT_WRAI);
			else if (player is "ReforgedCleric")
				can.SetWeapon(WT_PURI);
			else if (player is "ReforgedFighter")
				can.SetWeapon(WT_ZWEI);
			
			elements.Push(can);
		}
	}
	
	ui void DrawStats()
	{
		if (oldMenuState != MS_STAT)
		{
			ClearUI();
			
			let can = MenuElement.Create("StatCanvas", self, (960,500), (1320,780));
			if (can)
				elements.Push(can);
		}
		
		totalCost = 0;
		for (uint i = 0; i < stats.Size(); ++i)
		{
			if (stats[i])
				totalCost += stats[i].currentCost;
		}
	}
	
	ui bool CheckKeyBind(int keyScan, String alias)
	{
		if (!keyScan)
			return false;
		
		int key1, key2;
		[key1, key2] = Bindings.GetKeysForCommand(alias);
		
		return (key1 == keyScan || key2 == keyScan);
	}

	override bool InputProcess(InputEvent e)
	{
		if (!menuState)
			return false;
		
		mouse.x += e.mouseX*0.25;
		mouse.y += e.mouseY*-1.5;
			
		int mAct, bAct;
		if (e.Type == InputEvent.Type_KeyDown)
		{
			switch (e.keyScan)
			{
				case InputEvent.Key_Mouse1:
					mAct = MI_LEFTPRESS;
					break;
						
				case InputEvent.Key_Mouse2:
					mAct = MI_RIGHTPRESS;
					break;
			}
				
			if (CheckKeyBind(e.keyScan, "+use"))
			{
				if (menuState == MS_STAT)
					LevelPlayer();
					
				menuState = MS_CLOSED;
				bAct = BI_CLOSE;
			}
			else if (menuState == MS_INV && CheckKeyBind(e.keyScan, "invuse"))
				bAct = BI_USE;
		}
		else if (e.Type == InputEvent.Type_KeyUp)
		{
			switch (e.keyScan)
			{
				case InputEvent.Key_Mouse1:
					mAct = MI_LEFTRELEASE;
					break;
						
				case InputEvent.Key_Mouse2:
					mAct = MI_RIGHTRELEASE;
					break;
			}
		}
		
		if (mAct)
			mouseAction = mAct;
		if (bAct)
			buttonAction = bAct;
		
		if (mAct || bAct || e.Type == InputEvent.Type_Mouse)
			return true;
		
		return false;
	}
	
	override void ConsoleProcess(ConsoleEvent e)
	{
		if (e.Name ~== "ToggleInventory")
		{
			if (menuState == MS_INV)
				menuState = MS_CLOSED;
			else
			{
				player.currentPoints = player.points;
				menuState = MS_INV;
			}
		}
		else if (e.Name ~== "ToggleStats")
		{
			if (menuState == MS_STAT)
			{
				player.currentPoints = player.points;
				menuState = MS_CLOSED;
			}
			else
				menuState = MS_STAT;
		}
	}
	
	override void NetworkProcess(ConsoleEvent e)
	{
		if (e.IsManual)
			return;
		
		Array<string> command;
		e.Name.Split(command, ":");
				
		int size = command.Size();
		if (size == 2)
		{
			if (command[0] ~== "drop")
			{
				let inv = players[e.Player].mo.FindInventory(command[1]);
				if (inv)
					players[e.Player].mo.DropInventory(inv);
			}
			else if (command[0] ~== "use")
			{
				let inv = players[e.Player].mo.FindInventory(command[1]);
				if (inv)
					players[e.Player].mo.UseInventory(inv);
			}
			else if (command[0] ~== "swapskill")
			{
				let rpg = RPGPlayer(players[e.Player].mo);
				if (!rpg || e.args[0] >= rpg.skillSlots)
					return;
				
				if (command[1] ~== "null")
					rpg.SetActiveSkill(e.args[0]);
				else
					rpg.SetActiveSkill(e.args[0], (class<Skill>)(command[1]));
			}
		}
		else
		{
			if (command[0] ~== "levelup")
			{
				let rpg = RPGPlayer(players[e.Player].mo);
				if (!rpg)
					return;
					
				for (int i = 1; i < command.Size(); i += 2)
				{
					let stat = Stat(rpg.FindInventory(command[i]));
					if (stat)
						stat.LevelUp(command[i+1].ToInt(10) - stat.level);
				}
					
				rpg.currentXP -= e.args[0];
				rpg.points = e.args[1];
			}
			else if (command[0] ~== "swapitem")
			{
				let swapper = players[e.Player].mo.FindInventory(command[1]);
				let swappee = players[e.Player].mo.FindInventory(command[2]);
					
				if (!swapper || !swappee)
					return;
					
				Inventory swapperPrev, swappeePrev;
				for (let probe = players[e.Player].mo.inv; probe; probe = probe.inv)
				{
					if (probe.inv == swapper)
						swapperPrev = probe;
					else if (probe.inv == swappee)
						swappeePrev = probe;
						
					if (swapperPrev && swappeePrev)
						break;
				}
					
				if (swapperPrev)
					swapperPrev.inv = swappee;
				else
					players[e.Player].mo.inv = swappee;
					
				if (swappeePrev)
					swappeePrev.inv = swapper;
				else
					players[e.Player].mo.inv = swapper;
					
				let temp = swappee.inv;
				swappee.inv = swapper.inv;
				swapper.inv = temp;
			}
		}
	}
}