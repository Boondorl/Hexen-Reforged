class RPGMenuHandler : EventHandler
{
	enum EMenuInput
	{
		MI_LEFTPRESS = 1,
		MI_RIGHTPRESS = 2,
		MI_LEFTRELEASE = 3,
		MI_RIGHTRELEASE = 4,
		MI_LEFTHOLD = 5,
		MI_RIGHTHOLD = 6,
		BI_USEDITEM = 7
	};
	
	ui Array<Inventory> currentItems;
	ui Array<Inventory> currentKeyItems;
	ui Array<Skill> currentSkills;
	ui Array<Stat> currentStats;
	
	ui Array<ItemBox> items;
	ui Array<KeyItemBox> keyItems;
	ui Array<PassiveBox> stats;
	ui Array<InteractiveBox> skills;
	
	ui ConfirmStatsButton levelUp;
	ui int currentAction;
	ui int prevAction;
	
	ui bool bInitialized;
	ui bool bCleared;
	ui int mouseX;
	ui int mouseY;
	bool bMenuOpen;
	bool bInStats;
	bool bInInv;
	ui bool bStatsInitialized;
	ui int totalCost;
	ui int prevPoints;
	
	ui static bool GetMenuState()
	{
		let menu = RPGMenuHandler(EventHandler.Find("RPGMenuHandler"));
		if (menu)
			return menu.bMenuOpen;
		
		return false;
	}
	
	ui static Vector3 GetMouse()
	{
		let menu = RPGMenuHandler(EventHandler.Find("RPGMenuHandler"));
		if (menu)
			return (menu.mouseX, menu.mouseY, menu.currentAction);
		else
			return (-1, -1, 0);
	}
	
	ui static void LevelPlayer()
	{
		let menu = RPGMenuHandler(EventHandler.Find("RPGMenuHandler"));
		if (!menu)
			return;
		
		let rpg = RPGPlayer(players[consoleplayer].mo);
		if (!rpg)
			return;
		
		if (rpg.tempPoints == rpg.points && menu.totalCost <= 0)
			return;
		
		if (rpg.currentXP < menu.totalCost)
			return;
		
		string command = "levelup";
		
		for (int i = 0; i < menu.currentStats.Size(); ++i)
		{
			if (menu.currentStats[i].tempLevel == menu.currentStats[i].level)
				continue;
			
			menu.currentStats[i].tempCost = 0;
			command = String.Format("%s:%s:%d", command, menu.currentStats[i].GetClassName(), menu.currentStats[i].tempLevel);
		}
		
		EventHandler.SendNetworkEvent(command, menu.totalCost, rpg.tempPoints);
	}
	
	ui static ItemBox CheckItemCollision(ItemBox box)
	{
		let menu = RPGMenuHandler(EventHandler.Find("RPGMenuHandler"));
		if (!menu)
			return null;
		
		ItemBox collider;
		double distance = 101;
		for (int i = 0; i < menu.items.Size(); ++i)
		{
			let probe = menu.items[i];
			if (!probe || probe == box)
				continue;
			
			double temp = (probe.center - (menu.mouseX, menu.mouseY)).Length();
			if (temp > 100)
				continue;
			
			if (temp < distance)
			{
				collider = probe;
				distance = temp;
			}
		}
		
		return collider;
	}
	
	ui static void SwapItems(ItemBox held, ItemBox swap)
	{
		let menu = RPGMenuHandler(EventHandler.Find("RPGMenuHandler"));
		if (!menu)
			return;
		
		int heldIndex = menu.items.Find(held);
		int swapIndex = menu.items.Find(swap);
		
		menu.items[swapIndex] = held;
		menu.items[heldIndex] = swap;
		
		Vector2 temp = swap.absoluteCenter;
		swap.absoluteCenter = held.absoluteCenter;
		held.absoluteCenter = temp;
		
		string command = "swapitem:"..held.item.GetClassName()..":"..swap.item.GetClassName();
		EventHandler.SendNetworkEvent(command);
	}
	
	ui void CreateItem(class<ItemBox> type, int width, int height, Vector2 pos, Inventory item = null, int tolerance = 0)
	{
		let box = ItemBox(new(type));
		if (box)
		{
			box.width = width;
			box.height = height;
			box.absoluteCenter = pos;
			box.item = item;
			box.tolerance = tolerance;
			box.Initialize();
			currentItems.Push(item);
			items.Push(box);
		}
	}
	
	ui static KeyItemBox CheckKeyItemCollision(KeyItemBox box)
	{
		let menu = RPGMenuHandler(EventHandler.Find("RPGMenuHandler"));
		if (!menu)
			return null;
		
		KeyItemBox collider;
		double distance = 101;
		for (int i = 0; i < menu.keyItems.Size(); ++i)
		{
			let probe = menu.keyItems[i];
			if (!probe || probe == box)
				continue;
			
			double temp = (probe.center - (menu.mouseX, menu.mouseY)).Length();
			if (temp > 100)
				continue;
			
			if (temp < distance)
			{
				collider = probe;
				distance = temp;
			}
		}
		
		return collider;
	}
	
	ui static void SwapKeyItems(KeyItemBox held, KeyItemBox swap)
	{
		let menu = RPGMenuHandler(EventHandler.Find("RPGMenuHandler"));
		if (!menu)
			return;
		
		int heldIndex = menu.keyItems.Find(held);
		int swapIndex = menu.keyItems.Find(swap);
		
		menu.keyItems[swapIndex] = held;
		menu.keyItems[heldIndex] = swap;
		
		Vector2 temp = swap.absoluteCenter;
		swap.absoluteCenter = held.absoluteCenter;
		held.absoluteCenter = temp;
		
		string command = "swapitem:"..held.item.GetClassName()..":"..swap.item.GetClassName();
		EventHandler.SendNetworkEvent(command);
	}
	
	ui void CreateKeyItem(class<KeyItemBox> type, int width, int height, Vector2 pos, Inventory item = null, int tolerance = 0)
	{
		let box = KeyItemBox(new(type));
		if (box)
		{
			box.width = width;
			box.height = height;
			box.absoluteCenter = pos;
			box.item = item;
			box.tolerance = tolerance;
			box.Initialize();
			currentKeyItems.Push(item);
			keyItems.Push(box);
		}
	}
	
	ui void CreateStat(class<PassiveBox> type, int width, int height, Vector2 pos, Stat item = null, bool addStat = true, int tolerance = 0)
	{
		let box = PassiveBox(new(type));
		if (box)
		{
			box.width = width;
			box.height = height;
			box.absoluteCenter = pos;
			box.item = item;
			box.tolerance = tolerance;
			box.Initialize();
			stats.Push(box);
			
			if (addStat)
				currentStats.Push(item);
			else
				box.increment = 1;
		}
	}
	
	ui void CreateLevelUp(class<ConfirmStatsButton> type, int width, int height, Vector2 pos)
	{
		let box = ConfirmStatsButton(new(type));
		if (box)
		{
			box.width = width;
			box.height = height;
			box.absoluteCenter = pos;
			box.Initialize();
			levelUp = box;
		}
	}
	
	override void RenderOverlay(RenderEvent e)
	{
		if (!bInitialized)
		{
			int wOfs, hOfs, w, h;
			[wOfs, hOfs, w, h] = Screen.GetViewWindow();
			
			mouseX = wOfs + w/2;
			mouseY = hOfs + h/2;
			
			bInitialized = true;
		}
		
		if (!bMenuOpen)
		{
			if (!bCleared)
			{
				if (bStatsInitialized)
				{
					for (uint i = 0; i < currentStats.Size(); ++i)
					{
						let stat = currentStats[i];
						if (!stat)
							continue;
						
						EventHandler.SendNetworkEvent("updatestat:"..stat.GetClassName(), stat.level);
					}
				}
				
				currentItems.Clear();
				currentKeyItems.Clear();
				currentSkills.Clear();
				currentStats.Clear();
				
				for (uint i = 0; i < items.Size(); ++i)
				{
					if (items[i])
						items[i].Destroy();
				}
				items.Clear();
				
				for (uint i = 0; i < keyItems.Size(); ++i)
				{
					if (keyItems[i])
						keyItems[i].Destroy();
				}
				keyItems.Clear();
				
				for (uint i = 0; i < stats.Size(); ++i)
				{
					if (stats[i])
						stats[i].Destroy();
				}
				stats.Clear();
				
				for (uint i = 0; i < skills.Size(); ++i)
				{
					if (skills[i])
						skills[i].Destroy();
				}
				skills.Clear();
				
				bCleared = true;
				bStatsInitialized = false;
				prevPoints = 0;
			}
			
			return;
		}
		
		bCleared = false;
		
		switch (prevAction)
		{
			case MI_LEFTPRESS:
				currentAction = MI_LEFTHOLD;
				break;
						
			case MI_RIGHTPRESS:
				currentAction = MI_RIGHTHOLD;
				break;
						
			case MI_LEFTHOLD:
			case MI_RIGHTHOLD:
				break;
			
			case BI_USEDITEM:
			case MI_LEFTRELEASE:
			case MI_RIGHTRELEASE:
				currentAction = 0;
				break;
		}
		
		prevAction = currentAction;
		
		if (bInInv)
			DrawInventory();
		else
			DrawStats();
			
		Screen.DrawFrame(mouseX-1, mouseY-1, 3, 3);
	}
	
	ui void DrawInventory()
	{
		Font font = "BIGUPPER";
		int fHeight = font.GetHeight();
		
		DrawArmor(font, fHeight);
		DrawItems(font, fHeight);
		DrawKeyItems(font, fHeight);
	}
	
	ui void DrawArmor(Font font, int fHeight)
	{
		let am = ArmorPieceManager(players[consoleplayer].mo.FindInventory("ArmorPieceManager"));
		if (am)
		{
			int wOfs, hOfs, w, h;
			[wOfs, hOfs, w, h] = Screen.GetViewWindow();
			
			int hOffset = hOfs;
			int wOffset = wOfs + w;
			double ratio = min(w/1920., h/1080.);
				
			for (uint i = 0; i < am.pieces.Size(); ++i)
			{
				let piece = am.pieces[i];
				if (!piece)
					continue;
				
				Vector2 size = TexMan.GetScaledSize(piece.Icon);
				size.y *= 1.2;
				size *= 2 * ratio;
				
				int arw = size.x;
				int arh = size.y;
				
				Vector2 pos = (wOffset - size.x/2, hOffset + size.y);
				Screen.DrawTexture(piece.Icon, false, pos.x, pos.y,
									DTA_CenterBottomOffset, true, DTA_DestWidth, arw, DTA_DestHeight, arh);
				
				string health = String.Format("%d / %d", piece.health, piece.default.health);
				int length = Font.StringWidth(health);
				Screen.DrawText(font, Font.CR_WHITE, wOffset-length, hOffset + size.y, health);
				
				hOffset += size.y + fHeight;
			}
		}
	}
	
	ui void DrawItems(Font font, int fHeight)
	{
		let rpg = RPGPlayer(players[consoleplayer].mo);
		if (rpg)
			Screen.DrawText(font, Font.CR_RED, 0, 0, String.Format("Weight: %.1f / %.1f", rpg.currentCapacity/10., rpg.carryCapacity/10.));
		
		int hOffset = 150;
		int wOffset = 150;
		for (let probe = players[consoleplayer].mo.inv; probe != null; probe = probe.inv)
		{
			if (!probe || !probe.bInvBar)
				continue;
			
			if (currentItems.Find(probe) == currentItems.Size())
			{
				if (!items.Size())
					CreateItem("ItemBox", 100, 100, (wOffset, hOffset), probe);
				else
				{
					uint last = items.Size()-1;
					
					Vector2 offset = items[last].absoluteCenter + (150, 0);
					if (offset.x+150 > 1920)
					{
						wOffset = 150;
						while (hOffset <= items[last].absoluteCenter.y)
						{
							hOffset += 150;
						}
						
						offset.x = wOffset;
						offset.y = hOffset;
					}
					
					CreateItem("ItemBox", 100, 100, offset, probe);
				}
			}

			wOffset += 150;
			if (wOffset+150 > 1920)
			{
				wOffset = 150;
				hOffset += 150;
			}
		}
		
		for (int i = 0; i < items.Size(); ++i)
		{
			if (items[i].item && items[i].item.owner && items[i].item.amount > 0)
			{
				if (items[i].item.owner.player && items[i].item == items[i].item.owner.player.mo.invSel)
					items[i].bSelected = true;
				else
					items[i].bSelected = false;
				
				items[i].Execute();
			}
			else
			{
				for (int j = items.Size()-1; j > i; --j)
				{
					items[j].absoluteCenter = items[j-1].absoluteCenter;
				}
				
				items[i].Destroy();
				items.Delete(i);
				currentItems.Delete(i);
			}
		}
	}
	
	ui void DrawKeyItems(Font font, int fHeight)
	{
		int hOffset = 550;
		int wOffset = 150;
		for (let probe = players[consoleplayer].mo.inv; probe != null; probe = probe.inv)
		{
			if (!probe || (!(probe is "PuzzleItem") && !(probe is "Key")))
				continue;
			
			if (currentKeyItems.Find(probe) == currentKeyItems.Size())
			{
				if (!keyItems.Size())
					CreateKeyItem("KeyItemBox", 100, 100, (wOffset, hOffset), probe);
				else
				{
					uint last = keyItems.Size()-1;
					
					Vector2 offset = keyItems[last].absoluteCenter + (150, 0);
					if (offset.x+150 > 1920)
					{
						wOffset = 150;
						while (hOffset <= keyItems[last].absoluteCenter.y)
						{
							hOffset += 150;
						}
						
						offset.x = wOffset;
						offset.y = hOffset;
					}
					
					CreateKeyItem("KeyItemBox", 100, 100, offset, probe);
				}
			}

			wOffset += 150;
			if (wOffset+150 > 1920)
			{
				wOffset = 150;
				hOffset += 150;
			}
		}
		
		for (int i = 0; i < keyItems.Size(); ++i)
		{
			if (keyItems[i].item && keyItems[i].item.owner && keyItems[i].item.amount > 0)
				keyItems[i].Execute();
			else
			{
				for (int j = keyItems.Size()-1; j > i; --j)
				{
					keyItems[j].absoluteCenter = keyItems[j-1].absoluteCenter;
				}
				
				keyItems[i].Destroy();
				keyItems.Delete(i);
				currentkeyItems.Delete(i);
			}
		}
	}
	
	ui void DrawStats()
	{
		let rpg = RPGPlayer(players[consoleplayer].mo);
		if (!rpg)
			return;
		
		Font font = "BigUpper";
		int fHeight = font.GetHeight();
		
		Screen.DrawText(font, Font.CR_RED, 0, 0, String.Format("Level %d", rpg.currentLevel));
		Screen.DrawText(font, Font.CR_RED, 0, fHeight, String.Format("XP %d / %d", rpg.currentXP, rpg.nextLevelXP));
		
		int hOffset = 200;
		totalCost = 0;
		for (int i = 0; i < rpg.stats.Size(); ++i)
		{
			let stat = Stat(rpg.FindInventory(rpg.stats[i]));
			if (!stat)
				continue;
			
			if (currentStats.Find(stat) == currentStats.Size())
			{
				if (!stats.Size())
				{
					CreateStat("PassiveBox", 100, 100, (100, hOffset), stat);
					CreateStat("PassiveBox", 100, 100, (300, hOffset), stat, false);
				}
				else
				{
					uint last = stats.Size()-1;
					Vector2 offset = (100, stats[last].absoluteCenter.y + 100);
					hOffset += 100;
					CreateStat("PassiveBox", 100, 100, offset, stat);
					CreateStat("PassiveBox", 100, 100, (offset.x+200, offset.y), stat, false);
				}
			}
			
			if (!bStatsInitialized)
			{
				stat.tempLevel = stat.level;
				stat.tempCost = 0;
			}
			totalCost += stat.tempCost;
			
			hOffset += 100;
		}
		
		
		for (int i = 0; i < stats.Size(); ++i)
		{
			if (stats[i].item)
				stats[i].Execute();
			else
			{
				for (int j = stats.Size()-1; j > i; --j)
				{
					stats[j].absoluteCenter = stats[j-1].absoluteCenter;
				}
				
				stats[i].Destroy();
				stats.Delete(i);
				currentStats.Delete(i);
			}
		}
		
		if (!bStatsInitialized)
			rpg.tempPoints = rpg.points;
		else if (prevPoints != rpg.points && rpg.points != rpg.tempPoints)
			rpg.tempPoints += rpg.points - prevPoints;
		
		int wOfs, hOfs, w, h;
		[wOfs, hOfs, w, h] = Screen.GetViewWindow();
		
		if (totalCost > 0)
			Screen.DrawText(font, Font.CR_WHITE, wOfs + w/2, hOfs, String.Format("Requires %d XP", totalCost));
		
		if (!levelUp)
			CreateLevelUp("ConfirmStatsButton", 300, 100, (1920/2-150, 1080-200));
		
		if (levelUp && (rpg.points > 0 || rpg.tempPoints > 0) && (totalCost > 0 || rpg.points != rpg.tempPoints))
			levelUp.Execute();
		
		bStatsInitialized = true;
		prevPoints = rpg.points;
	}

	override bool InputProcess(InputEvent e)
	{
		if (bMenuOpen)
		{
			int wOfs, hOfs, w, h;
			[wOfs, hOfs, w, h] = Screen.GetViewWindow();
			
			mouseX += e.mouseX*0.25;
			mouseY += e.mouseY*-1.5;
			
			mouseX = clamp(mouseX, wOfs, wOfs+w);
			mouseY = clamp(mouseY, hOfs, hOfs+h);
			
			int input = 0;
			if (e.Type == InputEvent.Type_KeyDown)
			{
				switch (e.keyScan)
				{
					case InputEvent.Key_Mouse1:
						input = MI_LEFTPRESS;
						break;
						
					case InputEvent.Key_Mouse2:
						input = MI_RIGHTPRESS;
						break;
				}
				
				if (!input)
				{
					int key1, key2;
					[key1, key2] = Bindings.GetKeysForCommand("+use");
					
					if ((key1 && key1 == e.keyScan) || (key2 && key2 == e.keyScan))
					{
						if (bInStats)
						{
							RPGMenuHandler.LevelPlayer();
							EventHandler.SendNetworkEvent("ToggleStats");
						}
						else if (bInInv)
							EventHandler.SendNetworkEvent("ToggleInventory");
						
						input = -1;
					}
					else if (bInInv)
					{
						int key1, key2;
						[key1, key2] = Bindings.GetKeysForCommand("invuse");
						
						if ((key1 && key1 == e.keyScan) || (key2 && key2 == e.keyScan))
							input = BI_USEDITEM;
					}
				}
			}
			else if (e.Type == InputEvent.Type_KeyUp)
			{
				switch (e.keyScan)
				{
					case InputEvent.Key_Mouse1:
						input = MI_LEFTRELEASE;
						break;
						
					case InputEvent.Key_Mouse2:
						input = MI_RIGHTRELEASE;
						break;
				}
			}
			
			if (input)
			{
				if (input > 0)
					currentAction = input;
				
				return true;
			}
			
			if (e.Type == InputEvent.Type_Mouse)
				return true;
		}
		
		return false;
	}
	
	override void NetworkProcess(ConsoleEvent e)
	{
		if (e.Name == "ToggleStats" || e.Name == "ToggleInventory")
		{
			if (e.Name == "ToggleStats")
			{
				bInStats = !bInStats;
				if (bInInv)
					bInInv = false;
				else
					bMenuOpen = !bMenuOpen;
			}
			else
			{
				bInInv = !bInInv;
				if (bInStats)
					bInStats = false;
				else
					bMenuOpen = !bMenuOpen;
			}
		}
		else if (!e.IsManual)
		{
			Array<string> command;
			e.Name.Split(command, ":");
				
			int size = command.Size();
			if (size == 2)
			{
				if (command[0] ~== "drop")
				{
					let inv = players[consoleplayer].mo.FindInventory(command[1]);
					if (inv)
						players[consoleplayer].mo.DropInventory(inv);
				}
				else if (command[0] ~== "use")
				{
					let inv = players[consoleplayer].mo.FindInventory(command[1]);
					if (inv)
						players[consoleplayer].mo.UseInventory(inv);
				}
				else if (command[0] ~== "updatestat")
				{
					let rpg = RPGPlayer(players[consoleplayer].mo);
					if (!rpg)
						return;
					
					let stat = Stat(rpg.FindInventory(command[1]));
					if (stat)
						stat.displayLevel = e.args[0];
				}
			}
			else
			{
				if (command[0] ~== "levelup")
				{
					let rpg = RPGPlayer(players[consoleplayer].mo);
					if (!rpg)
						return;
					
					for (int i = 1; i < command.Size(); i += 2)
					{
						let stat = Stat(rpg.FindInventory(command[i]));
						if (stat)
							stat.LevelUp(command[i+1].ToInt(10) - stat.level);
					}
					
					rpg.currentXP -= e.args[0];
					rpg.points = e.args[1];
				}
				else if (command[0] ~== "swapitem")
				{
					Inventory held = players[consoleplayer].mo.FindInventory(command[1]);
					Inventory swap = players[consoleplayer].mo.FindInventory(command[2]);
					
					if (!held || !swap)
						return;
					
					Inventory heldPrev, swapPrev;
					for (let probe = players[consoleplayer].mo.inv; probe != null; probe = probe.inv)
					{
						if (probe.inv == held)
							heldPrev = probe;
						else if (probe.inv == swap)
							swapPrev = probe;
						
						if (heldPrev && swapPrev)
							break;
					}
					
					if (heldPrev)
						heldPrev.inv = swap;
					else
						players[consoleplayer].mo.inv = swap;
					
					if (swapPrev)
						swapPrev.inv = held;
					else
						players[consoleplayer].mo.inv = held;
					
					Inventory temp = swap.inv;
					swap.inv = held.inv;
					held.inv = temp;
				}
			}
		}
	}
}