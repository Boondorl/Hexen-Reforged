class Stat : Inventory abstract
{
	ui int currentLevel;
	ui int currentCost;
	
	Array<int> bonusValue;
	Array<String> bonusText;
	
	int level;
	int maxLevel;
	string description;
	int cost;
	int minLevel;
	
	property MinLevel : minLevel;
	property Level : level;
	property MaxLevel : maxLevel;
	property Description : description;
	property Cost : cost;
	
	Default
	{
		Stat.MinLevel 1;
		Stat.Level 1;
		Stat.MaxLevel 6;
		Stat.Cost 1000;
		
		+INVENTORY.UNDROPPABLE
		+NOBLOCKMAP
	}
	
	override void Tick() {}
	
	virtual void LevelUp(int levels, bool start = false)
	{
		level += levels;
		if (start)
			minLevel += levels;
	}
	
	virtual void GiveDefault() {}
}

class Agility : Stat
{
	Default
	{
		Tag "Agility";
		Stat.Description "Increases movement speed, carrying capacity, and reduces skill cool downs";
	}
	
	override void LevelUp(int levels, bool start)
	{
		super.LevelUp(levels, start);
		
		owner.player.mo.speed += 0.05*levels;
		let rpg = RPGPlayer(owner.player.mo);
		if (rpg)
		{
			rpg.carryCapacity += 20*levels;
			rpg.coolDownModifier -= 0.1*levels;
		}
	}
	
	override void PostBeginPlay()
	{
		super.PostBeginPlay();
		
		bonusValue.Push(5);
		bonusText.Push("% movement speed, ");
		bonusValue.Push(2);
		bonusText.Push(" carry capacity, ");
		bonusValue.Push(-5);
		bonusText.Push("% skill cool down duration");
	}
}

class Vitality : Stat
{
	Default
	{
		Tag "Vitality";
		Stat.Description "Increases maximum health";
	}
	
	override void LevelUp(int levels, bool start)
	{
		super.LevelUp(levels, start);
		
		owner.player.mo.maxHealth += 30*levels;
		if (start)
			owner.player.mo.GiveBody(30*levels);
		else if (levels < 0)
		{
			int diff = owner.player.mo.health - owner.player.mo.maxHealth;
			if (diff > 0)
			{
				owner.player.mo.health -= diff;
				owner.player.health = owner.player.mo.health;
			}
		}
	}
	
	override void PostBeginPlay()
	{
		super.PostBeginPlay();
		
		bonusValue.Push(30);
		bonusText.Push(" health");
	}
}

class Wisdom : Stat
{
	Default
	{
		Tag "Wisdom";
		Stat.Description "Increases maximum mana";
	}
	
	override void LevelUp(int levels, bool start)
	{
		super.LevelUp(levels, start);
		
		let bmana = Ammo(owner.player.mo.FindInventory("BlueMana"));
		if (bmana)
		{
			bmana.MaxAmount += 30*levels;
			bmana.BackpackMaxAmount += 30*levels;
			if (start)
				bmana.amount += 30*levels;
			else if (levels < 0)
			{
				int diff = bmana.amount - bmana.maxAmount;
				if (diff > 0)
					bmana.amount -= diff;
			}
		}
		
		let gmana = Ammo(owner.player.mo.FindInventory("GreenMana"));
		if (gmana)
		{
			gmana.MaxAmount += 30*levels;
			gmana.BackpackMaxAmount += 30*levels;
			if (start)
				gmana.amount += 30*levels;
			else if (levels < 0)
			{
				int diff = gmana.amount - gmana.maxAmount;
				if (diff > 0)
					gmana.amount -= diff;
			}
		}
		
		let rmana = Ammo(owner.player.mo.FindInventory("RedMana"));
		if (rmana)
		{
			rmana.MaxAmount += 30*levels;
			rmana.BackpackMaxAmount += 30*levels;
			if (levels < 0)
			{
				int diff = rmana.amount - rmana.maxAmount;
				if (diff > 0)
					rmana.amount -= diff;
			}
		}
	}
	
	override void GiveDefault()
	{
		let bmana = Ammo(owner.player.mo.FindInventory("BlueMana"));
		if (bmana)
		{
			bmana.MaxAmount += 30*(level-1);
			bmana.BackpackMaxAmount += 30*(level-1);
			bmana.Amount = bmana.MaxAmount;
		}
		
		let gmana = Ammo(owner.player.mo.FindInventory("GreenMana"));
		if (gmana)
		{
			gmana.MaxAmount += 30*(level-1);
			gmana.BackpackMaxAmount += 30*(level-1);
			gmana.Amount = gmana.MaxAmount;
		}
		
		let rmana = Ammo(owner.player.mo.FindInventory("RedMana"));
		if (rmana)
		{
			rmana.MaxAmount += 30*(level-1);
			rmana.BackpackMaxAmount += 30*(level-1);
		}
	}
	
	override void PostBeginPlay()
	{
		super.PostBeginPlay();
		
		bonusValue.Push(30);
		bonusText.Push(" mana");
	}
}

class Intelligence : Stat
{
	static const Name bonus[] = {'Fire', 'Ice', 'Electric', 'Poison', 'Burn', 'Illness'};
	
	Default
	{
		Tag "Intelligence";
		Stat.Description "Shows mastery in the arcane by increasing magic damage";
	}
	
	override void ModifyDamage(int damage, Name damageType, out int newdamage, bool passive, Actor inflictor, Actor source, int flags)
	{
		if (level <= 1)
			return;
		
		if (!passive)
		{
			bool bonusDmg = false;
			for (int i = 0; i < bonus.Size(); ++i)
			{
				if (damageType == bonus[i])
				{
					bonusDmg = true;
					break;
				}
			}
			
			if (bonusDmg)
				newdamage = round(newdamage * (1 + 0.1*(level-1)));
		}
	}
	
	override void PostBeginPlay()
	{
		super.PostBeginPlay();
		
		bonusValue.Push(10);
		bonusText.Push("% magic damage (fire, ice, lightning, poison)");
	}
}

class Strength : Stat
{
	static const Name bonus[] = {'Cleave', 'Pierce', 'Blunt', 'Bleed', 'Melee', 'Hitscan'};
	
	Default
	{
		Tag "Strength";
		Stat.Description "Shows mastery in heavy weaponry by increasing physical damage";
	}
	
	override void ModifyDamage(int damage, Name damageType, out int newdamage, bool passive, Actor inflictor, Actor source, int flags)
	{
		if (level <= 1)
			return;
		
		if (!passive)
		{
			bool bonusDmg = false;
			for (int i = 0; i < bonus.Size(); ++i)
			{
				if (damageType == bonus[i])
				{
					bonusDmg = true;
					break;
				}
			}
			
			if (bonusDmg)
				newdamage = round(newdamage * (1 + 0.1*(level-1)));
		}
	}
	
	override void PostBeginPlay()
	{
		super.PostBeginPlay();
		
		bonusValue.Push(10);
		bonusText.Push("% physical damage (cleave, blunt, pierce)");
	}
}

class Dexterity : Stat
{
	private State prevState;
	private double prevOffset;
	private double modifier;
	
	private int ticsToRemove;
	private double interval;
	private int ticTimer;
	
	Default
	{
		Tag "Dexterity";
		Stat.Description "Shows mastery of all weapons by reducing the  time needed to swap weapons, attack, and cast spells";
	}
	
	override void PostBeginPlay()
	{
		super.PostBeginPlay();
		
		if (owner && owner.player)
		{
			let psp = owner.player.GetPSprite(PSP_WEAPON);
			if (psp)
				prevOffset = psp.y;
		}
		
		bonusValue.Push(-5);
		bonusText.Push("% reduced swap, cast, and attack time");
	}
	
	override void LevelUp(int levels, bool start)
	{
		super.LevelUp(levels, start);
		
		let rpg = RPGPlayer(owner.player.mo);
		if (rpg)
			rpg.attackModifier -= 0.05*levels;
	}
	
	// Move this to the player
	override void DoEffect()
	{
		if (level > 1)
		{
			modifier = (level-1) / (100 / 5.);
			 
			let weap = owner.player.ReadyWeapon;
			if (!weap)
				return;
			
			let psp = owner.player.GetPSprite(PSP_WEAPON);
			if (!psp || !psp.CurState)
				return;
			
			State raise = weap.GetUpState();
			State lower = weap.GetDownState();
			State ready = weap.GetReadyState();
			
			bool inRaise = raise != ready && psp.CurState.InStateSequence(raise);
			bool inLower = lower != ready && psp.CurState.InStateSequence(lower);
			
			if (inRaise || inLower)
			{
				int diff = psp.y - prevOffset;
				psp.y += diff*modifier;
			}
			else
			{
				bool inParry = psp.CurState.InStateSequence(weap.FindState("Parry"));
				bool inBlock = psp.CurState.InStateSequence(weap.FindState("Reload"));
						
				if (inParry || inBlock)
				{
					ticsToRemove = 0;
					ticTimer = 0;
					interval = 0;
				}
				else
				{
					bool inReady = weap.GetAtkState(false) != ready && psp.CurState.InStateSequence(ready);
					int dist = 0;
					if (!inReady && prevState)
						dist = prevState.DistanceTo(psp.CurState);
								
					if (dist < 0 || (dist >= 1 && !psp.CurState.InStateSequence(prevState)))
						CalculateTics(psp.CurState);
				}
			}
						
			prevState = psp.CurState;
			prevOffset = psp.y;
					
			RemoveTics();
		}
	}
	
	private void CalculateTics(State current)
	{
		ticsToRemove = 0;
		ticTimer = 0;
		interval = 0;
		
		if (!current)
			return;
							
		int totalTics = 0;
		State thisState = current;
		State lastState;
		do
		{
			totalTics += thisState.tics;
								
			lastState = thisState;
			thisState = thisState.NextState;
		} while (thisState && lastState.DistanceTo(thisState) == 1);
							
		ticsToRemove = round(totalTics * modifier);
		ticsToRemove = min(ticsToRemove, totalTics);
						
		totalTics -= ticsToRemove;
						
		if (totalTics <= 0 && ticsToRemove > 0)
			interval = -1.;
		else if (ticsToRemove > 0)
			interval = totalTics*1. / ticsToRemove;
	}
	
	private void RemoveTics()
	{
		let psp = owner.player.GetPSprite(PSP_WEAPON);
		if (!psp || !psp.CurState)
		{
			ticsToRemove = 0;
			ticTimer = 0;
			interval = 0;
			return;
		}
		
		if (ticsToRemove > 0 && psp.CurState.tics > 0)
		{
			bool deleteAll = (interval == -1.);
			if (deleteAll)
				interval = 1.;
			
			if (interval <= 0)
			{
				ticsToRemove = 0;
				ticTimer = 0;
				interval = 0;
			}
			else if (!(ticTimer++ % ceil(interval)))
			{
				int mod = 1;
				if (deleteAll)
					mod = ticsToRemove;
				else if (interval < 1)
					mod = ceil(1/interval);
				
				mod = min(ticsToRemove, mod);
					
				if (psp.tics > mod)
					psp.tics -= mod;
				else
				{
					int temp = mod;
					do
					{
						int tempMod = min(temp, psp.tics);
						temp -= tempMod;
						psp.tics -= tempMod;
						if (psp.tics <= 0)
						{
							prevState = psp.CurState;
							owner.player.SetPsprite(PSP_WEAPON, psp.CurState.NextState);
						}
					} while (temp > 0);
				}
				
				ticsToRemove -= mod;
			}
		}
	}
}