class Stat : Inventory abstract
{
	int level;
	int maxLevel;
	string description;
	int cost;
	int minLevel;
	
	property MinLevel : minLevel;
	property Level : level;
	property MaxLevel : maxLevel;
	property Description : description;
	property Cost : cost;
	
	ui int tempLevel;
	ui int tempCost;
	int displayLevel;
	string currentBonus;
	
	Default
	{
		Stat.MinLevel 1;
		Stat.Level 1;
		Stat.MaxLevel 6;
		Stat.Cost 1000;
		
		+INVENTORY.UNDROPPABLE
	}
	
	virtual void LevelUp(int levels, bool start = false)
	{
		level += levels;
		displayLevel = level;
		if (start)
			minLevel += levels;
	}
	
	virtual void GiveDefault() {}
	
	override void BeginPlay()
	{
		super.BeginPlay();
		
		displayLevel = level;
	}
}

class Agility : Stat
{
	Default
	{
		Tag "Agility";
		Stat.Description "Increases movement speed, carrying capacity,\nand reduces skill cool downs";
	}
	
	override void LevelUp(int levels, bool start)
	{
		super.LevelUp(levels, start);
		
		owner.player.mo.speed += 0.05*levels;
		let rpg = RPGPlayer(owner.player.mo);
		if (rpg)
		{
			rpg.carryCapacity += 20*levels;
			rpg.skillCoolDown -= 0.1*levels;
		}
	}
	
	override void DoEffect()
	{
		super.DoEffect();
		
		if (displayLevel > 1)
			currentBonus = String.Format("+%d%% move speed, +%d carry capacity, -%d%% skill cool down", 5*(displayLevel-1), 2*(displayLevel-1), 10*(displayLevel-1));
		else
			currentBonus = "";
	}
}

class Vitality : Stat
{
	Default
	{
		Tag "Vitality";
		Stat.Description "Increases maximum health";
	}
	
	override void LevelUp(int levels, bool start)
	{
		super.LevelUp(levels, start);
		
		owner.player.mo.maxHealth += 30*levels;
		if (start)
			owner.player.mo.GiveBody(30*levels);
		else if (levels < 0)
		{
			int diff = owner.player.mo.health - owner.player.mo.maxHealth;
			if (diff > 0)
			{
				owner.player.mo.health -= diff;
				owner.player.health = owner.player.mo.health;
			}
		}
	}
	
	override void DoEffect()
	{
		super.DoEffect();
		
		if (displayLevel > 1)
			currentBonus = String.Format("+%d max health", 30*(displayLevel-1));
		else
			currentBonus = "";
	}
}

class Wisdom : Stat
{
	Default
	{
		Tag "Wisdom";
		Stat.Description "Increases maximum mana";
	}
	
	override void LevelUp(int levels, bool start)
	{
		super.LevelUp(levels, start);
		
		let bmana = Ammo(owner.player.mo.FindInventory("BlueMana"));
		if (bmana)
		{
			bmana.MaxAmount += 30*levels;
			bmana.BackpackMaxAmount += 30*levels;
			if (start)
				bmana.amount += 30*levels;
			else if (levels < 0)
			{
				int diff = bmana.amount - bmana.maxAmount;
				if (diff > 0)
					bmana.amount -= diff;
			}
		}
		
		let gmana = Ammo(owner.player.mo.FindInventory("GreenMana"));
		if (gmana)
		{
			gmana.MaxAmount += 30*levels;
			gmana.BackpackMaxAmount += 30*levels;
			if (start)
				gmana.amount += 30*levels;
			else if (levels < 0)
			{
				int diff = gmana.amount - gmana.maxAmount;
				if (diff > 0)
					gmana.amount -= diff;
			}
		}
		
		let rmana = Ammo(owner.player.mo.FindInventory("RedMana"));
		if (rmana)
		{
			rmana.MaxAmount += 30*levels;
			rmana.BackpackMaxAmount += 30*levels;
			if (levels < 0)
			{
				int diff = rmana.amount - rmana.maxAmount;
				if (diff > 0)
					rmana.amount -= diff;
			}
		}
	}
	
	override void GiveDefault()
	{
		let bmana = Ammo(owner.player.mo.FindInventory("BlueMana"));
		if (bmana)
		{
			bmana.MaxAmount += 30*(level-1);
			bmana.BackpackMaxAmount += 30*(level-1);
			bmana.Amount = bmana.MaxAmount;
		}
		
		let gmana = Ammo(owner.player.mo.FindInventory("GreenMana"));
		if (gmana)
		{
			gmana.MaxAmount += 30*(level-1);
			gmana.BackpackMaxAmount += 30*(level-1);
			gmana.Amount = gmana.MaxAmount;
		}
		
		let rmana = Ammo(owner.player.mo.FindInventory("RedMana"));
		if (rmana)
		{
			rmana.MaxAmount += 30*(level-1);
			rmana.BackpackMaxAmount += 30*(level-1);
		}
	}
	
	override void DoEffect()
	{
		super.DoEffect();
		
		if (displayLevel > 1)
			currentBonus = String.Format("+%d maximum mana", 30*(displayLevel-1));
		else
			currentBonus = "";
	}
}

class Intelligence : Stat
{
	static const Name bonus[] = {'Fire', 'Ice', 'Electric', 'Poison', 'Burn', 'Illness'};
	
	Default
	{
		Tag "Intelligence";
		Stat.Description "Shows mastery in the arcane by increasing\nmagic damage";
	}
	
	override void DoEffect()
	{
		super.DoEffect();
		
		if (displayLevel > 1)
			currentBonus = String.Format("+%d%% magic damage (fire, ice, lightning, poison)", 10*(displayLevel-1));
		else
			currentBonus = "";
	}
	
	override void ModifyDamage(int damage, Name damageType, out int newdamage, bool passive, Actor inflictor, Actor source, int flags)
	{
		if (level <= 1)
			return;
		
		if (!passive)
		{
			bool bonusDmg = false;
			for (int i = 0; i < bonus.Size(); ++i)
			{
				if (damageType == bonus[i])
				{
					bonusDmg = true;
					break;
				}
			}
			
			if (bonusDmg)
				newdamage = round(newdamage * (1 + 0.1*(level-1)));
		}
	}
}

class Strength : Stat
{
	static const Name bonus[] = {'Cleave', 'Pierce', 'Blunt', 'Bleed', 'Melee', 'Hitscan'};
	
	Default
	{
		Tag "Strength";
		Stat.Description "Shows mastery in heavy weaponry by increasing\nphysical damage";
	}
	
	override void DoEffect()
	{
		super.DoEffect();
		
		if (displayLevel > 1)
			currentBonus = String.Format("+%d%% physical damage (cleave, blunt, pierce)", 10*(displayLevel-1));
		else
			currentBonus = "";
	}
	
	override void ModifyDamage(int damage, Name damageType, out int newdamage, bool passive, Actor inflictor, Actor source, int flags)
	{
		if (level <= 1)
			return;
		
		if (!passive)
		{
			bool bonusDmg = false;
			for (int i = 0; i < bonus.Size(); ++i)
			{
				if (damageType == bonus[i])
				{
					bonusDmg = true;
					break;
				}
			}
			
			if (bonusDmg)
				newdamage = round(newdamage * (1 + 0.1*(level-1)));
		}
	}
}

class Dexterity : Stat
{
	private State prevState;
	private double prevOffset;
	
	private int ticsToRemove;
	private double interval;
	private int ticTimer;
	
	Default
	{
		Tag "Dexterity";
		Stat.Description "Shows mastery of all weapons by reducing the\n time needed to swap weapons, attack, and cast spells";
	}
	
	override void PostBeginPlay()
	{
		super.PostBeginPlay();
		
		if (owner && owner.player)
		{
			let psp = owner.player.GetPSprite(PSP_WEAPON);
			if (psp)
				prevOffset = psp.y;
		}
	}
	
	override void LevelUp(int levels, bool start)
	{
		super.LevelUp(levels, start);
		
		let rpg = RPGPlayer(owner.player.mo);
		if (rpg)
			rpg.attackModifier -= 0.05*levels;
	}
	
	override void DoEffect()
	{
		super.DoEffect();
		
		if (displayLevel > 1)
			currentBonus = String.Format("-%d%% swap, attack, and cast time", 5*(displayLevel-1));
		else
			currentBonus = "";
		
		if (level > 1)
		{
			let weap = owner.player.ReadyWeapon;
			if (weap)
			{
				let psp = owner.player.GetPSprite(PSP_WEAPON);
				
				if (psp && psp.CurState)
				{
					State raising = weap.GetUpState();
					State lowering = weap.GetDownState();
					State ready = weap.GetReadyState();
					double modifier = (level-1) / (100 / 5.);
					
					if (psp.CurState.InStateSequence(raising) || psp.CurState.InStateSequence(lowering))
					{
						int diff = psp.y - prevOffset;
						psp.y += diff*modifier;
					}
					
					bool inParry = psp.CurState.InStateSequence(weap.FindState("Parry"));
					bool inBlock = psp.CurState.InStateSequence(weap.FindState("Reload"));
					bool inReady = psp.CurState.InStateSequence(ready);
					
					if (inParry || inBlock)
						ticsToRemove = 0;
					
					int dist = 0;
					if (!inReady && !inParry && !inBlock)
					{
						if (prevState && !prevState.InStateSequence(ready))
							dist = prevState.DistanceTo(psp.CurState);
						else
							dist = 1;
					}
						
					if (dist < 0 || (dist >= 1 && !psp.CurState.InStateSequence(prevState)))
					{
						ticTimer = 0;
						interval = 0;
							
						int totalTics = 0;
						State thisState = psp.CurState;
						State lastState;
						do
						{
							totalTics += thisState.tics;
								
							lastState = thisState;
							thisState = thisState.NextState;
						} while (thisState && lastState.DistanceTo(thisState) == 1);
							
						ticsToRemove = round(totalTics * modifier);
						ticsToRemove = min(ticsToRemove, totalTics);
						
						totalTics -= ticsToRemove;
						
						if (totalTics <= 0 && ticsToRemove > 0)
							interval = -1.;
						else if (ticsToRemove > 0)
							interval = totalTics*1. / ticsToRemove;
						
						Console.printf("%d", ticsToRemove);
					}
						
					prevState = psp.CurState;
					prevOffset = psp.y;
					
					RemoveTics();
				}
			}
		}
	}
	
	private void RemoveTics()
	{
		let psp = owner.player.GetPSprite(PSP_WEAPON);
		if (!psp || !psp.CurState)
		{
			ticsToRemove = 0;
			return;
		}
		
		if (ticsToRemove > 0 && psp.CurState.tics > 0)
		{
			bool deleteAll = (interval == -1.);
			if (deleteAll)
				interval = 1.;
			
			if (interval <= 0)
				ticsToRemove = 0;
			else if (!(ticTimer++ % ceil(interval)))
			{
				int mod = 1;
				if (deleteAll)
					mod = ticsToRemove;
				else if (interval < 1)
					mod = ceil(1/interval);
				
				mod = min(ticsToRemove, mod);
					
				if (psp.tics > mod)
					psp.tics -= mod;
				else
				{
					int temp = mod;
					do
					{
						int tempMod = min(temp, psp.tics);
						temp -= tempMod;
						psp.tics -= tempMod;
						if (psp.tics <= 0)
						{
							prevState = psp.CurState;
							owner.player.SetPsprite(PSP_WEAPON, psp.CurState.NextState);
						}
					} while (temp > 0);
				}
				
				ticsToRemove -= mod;
			}
		}
	}
}