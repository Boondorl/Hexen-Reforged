class MenuElement : Object ui
{
	MenuHandler handler;
	MenuElement parent;
	Array<MenuElement> children;
	MenuElement touching;
	
	bool bTile;
	TextureID background;
	double backgroundAlpha;
	double backgroundScale;
	double backgroundDesaturation;
	int backgroundColor;
	
	int age;
	Vector2 size;
	Vector2 center;
	Vector2 tolerance;
	
	Vector2 scaledSize;
	Vector2 scaledCenter;
	Vector2 scaledTolerance;
	Vector2 scalar;
	
	bool bKeepAspectRatio;
	bool bCenter;
	bool bInvisible;
	bool bNoCollision;
	
	bool bLeftClicked;
	bool bRightClicked;
	bool bSelected;
	bool bHeld;
	bool bHovering;
	
	protected int holdTimer;
	protected uint deltatime;
	private uint prevTime;
	
	static MenuElement Create(class<MenuElement> type, MenuHandler han, Vector2 pos, Vector2 size, MenuElement par = null)
	{
		let element = MenuElement(new(type));
		if (!element)
			return null;
		
		element.handler = han;
		element.center = pos;
		element.size = size;
		
		if (par)
		{
			element.parent = par;
			par.children.Push(element);
		}
		
		element.Initialize();
		
		return element;
	}
	
	void DrawTexture(TextureID texture, Vector2 pos, Vector2 scale = (1,1), double alpha = 1, int color = 0)
	{
		if (bInvisible || !scale.x || !scale.y)
			return;
			
		Vector2 size = TexMan.GetScaledSize(texture);
		size.y *= 1.2;
			
		size.x *= scale.x;
		size.y *= scale.y;
			
		if (bKeepAspectRatio)
			size *= min(scalar.x, scalar.y);
		else
		{
			size.x *= scalar.x;
			size.y *= scalar.y;
		}
			
		Screen.DrawTexture(texture, false, pos.x, pos.y,
							DTA_CenterOffset, true, DTA_DestWidthF, size.x, DTA_DestHeightF, size.y,
							DTA_Alpha, alpha, DTA_ColorOverlay, color);
	}
	
	void DrawText(Font fnt, int color, Vector2 pos, string text, Vector2 offset = (0,0), double scale = 1)
	{
		if (bInvisible || !scale)
			return;
		
		double vWidth = Screen.GetWidth();
		double vHeight = Screen.GetHeight();
		
		double ratio = min(scalar.x, scalar.y) * scale;
		vWidth /= ratio;
		vHeight /= ratio;
		
		offset *= ratio;
		
		pos.x += offset.x;
		pos.y += offset.y;
		
		pos /= ratio;
				
		Screen.DrawText(fnt, color, pos.x, pos.y, text,
						DTA_VirtualWidthF, vWidth, DTA_VirtualHeightF, vHeight, DTA_KeepRatio, true);
	}
	
	void CheckCollision(MenuElement other)
	{
		if (!other || self == other)
			return;
		
		if (!bNoCollision)
		{
			Vector2 orMin = (scaledCenter.x - scaledTolerance.x, scaledCenter.y - scaledTolerance.y);
			Vector2 orMax = (scaledCenter.x + scaledTolerance.x, scaledCenter.y + scaledTolerance.y);
			
			Vector2 otMin = (other.scaledCenter.x - other.scaledTolerance.x, other.scaledCenter.y - other.scaledTolerance.y);
			Vector2 otMax = (other.scaledCenter.x + other.scaledTolerance.x, other.scaledCenter.y + other.scaledTolerance.y);
			
			if ((orMin.x <= otMax.x && orMax.x >= otMin.x) &&
				(orMin.y <= otMax.y && orMax.y >= otMin.y))
			{
				if (!other.touching)
					other.touching = self;
				else
				{
					if (other.DistanceToSquared(touching) > other.DistanceToSquared(self))
						other.touching = self;
				}
			}
		}
		
		for (uint i = 0; i < children.Size(); ++i)
		{
			if (children[i])
				children[i].CheckCollision(other);
		}
	}
	
	double DistanceTo(MenuElement other)
	{
		if (!other)
			return double.max;
		
		return (other.scaledCenter - scaledCenter).Length();
	}
	
	double DistanceToSquared(MenuElement other)
	{
		if (!other)
			return double.max;
		
		Vector2 temp = other.scaledCenter - scaledCenter;
		return (temp dot temp);
	}
	
	void Shift(Vector2 diff)
	{
		center += diff;
		for (uint i = 0; i < children.Size(); ++i)
		{
			if (children[i])
				children[i].Shift(diff);
		}
	}
	
	void DrawBackground()
	{
		if (!background.IsValid())
			return;
		
		int desat = 255 * backgroundDesaturation;
		
		if (bTile)
		{
			int cx, cy, cw, ch;
			[cx, cy, cw, ch] = Screen.GetClipRect();
			
			Screen.SetClipRect(scaledCenter.x - scaledSize.x/2, scaledCenter.y - scaledSize.y/2, scaledSize.x, scaledSize.y);
			
			Vector2 s = TexMan.GetScaledSize(background);
			s.y *= 1.2;
			
			s *= min(scalar.x, scalar.y) * backgroundScale;
			
			
			Vector2 pos = (scaledCenter.x - scaledSize.x/2 + s.x/2, scaledCenter.y - scaledSize.y/2 + s.y/2);
			while (pos.y - s.y/2 < scaledCenter.y + scaledSize.y/2)
			{
				Screen.DrawTexture(background, true, pos.x, pos.y,
									DTA_CenterOffset, true, DTA_DestWidthF, s.x, DTA_DestHeightF, s.y,
									DTA_Alpha, backgroundAlpha, DTA_Desaturate, desat, DTA_ColorOverlay, backgroundColor);
				
				pos.x += s.x;
				if (pos.x - s.x/2 >= scaledCenter.x+scaledSize.x/2)
				{
					pos.x = scaledCenter.x - scaledSize.x/2 + s.x/2;
					pos.y += s.y;
				}
			} 
			
			Screen.SetClipRect(cx, cy, cw, ch);
		}
		else
		{
			Screen.DrawTexture(background, true, scaledCenter.x, scaledCenter.y,
								DTA_CenterOffset, true, DTA_DestWidthF, scaledSize.x, DTA_DestHeightF, scaledSize.y,
								DTA_Alpha, backgroundAlpha, DTA_Desaturate, desat, DTA_ColorOverlay, backgroundColor);
		}

	}
	
	virtual void Initialize()
	{
		bCenter = true;
		bKeepAspectRatio = true;
		tolerance = (size.x / 2, size.y / 2);
		backgroundAlpha = 1;
		backgroundScale = 1;
	}
	
	virtual void Clear()
	{
		bLeftClicked = false;
		bRightClicked = false;
		bSelected = false;
		bHeld = false;
		holdTimer = 0;
	}
	
	virtual void OnHover() {}
	
	virtual void OnHeld() {}
	
	virtual void OnSelected() {}
	
	virtual void OnLeftClick() {}
	
	virtual void OnRightClick() {}
	
	virtual void OnLeftHold() {}
	
	virtual void OnRightHold() {}
	
	virtual void OnLeftRelease() {}
	
	virtual void OnRightRelease() {}
	
	virtual void PreChild(double fracTic) {}
	
	virtual void PostChild(double fracTic) {}
	
	virtual void Tick()
	{
		++age;
		for (uint i = 0; i < children.Size(); ++i)
		{
			if (children[i])
				children[i].Tick();
		}
	}
	
	virtual void Execute(double fracTic)
	{
		uint currentTime = MSTime();
		if (!prevTime)
			prevTime = currentTime;
		
		deltatime = currentTime - prevTime;
		if (deltaTime > 200) // Cap to a minimum of 5 FPS
			deltaTime = 200;
		
		prevTime = currentTime;
		
		touching = null;
		bHovering = false;
		
		int wOfs, hOfs, w, h;
		[wOfs, hOfs, w, h] = Screen.GetViewWindow();
		
		scalar.x = w / 1920.;
		scalar.y = h / 1080.;
		
		if (bKeepAspectRatio)
		{
			double ratio = min(scalar.x, scalar.y);
			
			scaledSize = size * ratio;
			scaledTolerance = tolerance * ratio;
		}
		else
		{
			scaledSize.x = size.x * scalar.x;
			scaledSize.y = size.y * scalar.y;
			
			scaledTolerance.x = tolerance.x * scalar.x;
			scaledTolerance.y = tolerance.y * scalar.y;
		}
		
		if (bCenter)
		{
			double ratio = min(scalar.x, scalar.y);
			scaledCenter.x = wOfs + center.x*ratio + abs(1920*ratio - 1920*scalar.x)/2;
			scaledCenter.y = hOfs + center.y*ratio + abs(1080*ratio - 1080*scalar.y)/2;
		}
		else
		{
			scaledCenter.x = wOfs + center.x * scalar.x;
			scaledCenter.y = hOfs + center.y * scalar.y;
		}
		
		DrawBackground();
		
		double sw = scaledSize.x / 2;
		double sh = scaledSize.y / 2;
			
		if (bHeld ||
			(handler.mouse.x >= (scaledCenter.x-sw) && handler.mouse.x <= (scaledCenter.x+sw) &&
			handler.mouse.y >= (scaledCenter.y-sh) && handler.mouse.y <= (scaledCenter.y+sh)))
		{
			switch (handler.mouseAction)
			{
				case MI_LEFTPRESS:
					bLeftClicked = true;
					OnLeftClick();
					break;
						
				case MI_LEFTHOLD:
					OnLeftHold();
					break;
						
				case MI_LEFTRELEASE:
					OnLeftRelease();
					bLeftClicked = false;
					break;
						
				case MI_RIGHTPRESS:
					bRightClicked = true;
					OnRightClick();
					break;
						
				case MI_RIGHTHOLD:
					OnRightHold();
					break;
						
				case MI_RIGHTRELEASE:
					OnRightRelease();
					bRightClicked = false;
					break;
			}
				
			if (bHeld)
				OnHeld();
			else
			{
				bHovering = true;
				OnHover();
			}
		}
		else
		{
			holdTimer = 0;
			bLeftClicked = false;
			bRightClicked = false;
		}
		
		if (!bHeld && bSelected)
			OnSelected();
		
		PreChild(fracTic);
		
		for (uint i = 0; i < children.Size(); ++i)
		{
			if (children[i])
				children[i].Execute(fracTic);
		}
		
		PostChild(fracTic);
	}
	
	override void OnDestroy()
	{
		for (uint i = 0; i < children.Size(); ++i)
		{
			if (children[i])
				children[i].Destroy();
		}
		
		super.OnDestroy();
	}
}

class TextBox : MenuElement
{
	String text;
	double textScale;
	
	override void Initialize()
	{
		super.Initialize();
		
		bTile = true;
		backgroundDesaturation = 1;
		backgroundColor = 0x9F000000;
		background = TexMan.CheckForTexture("AUTOPAGE", TexMan.Type_Any);
		textScale = 2;
		bNoCollision = true;
		
		if (center.x + size.x/2 > 1920)
			center.x = 1920 - size.x/2;
		else if (center.x - size.x/2 < 0)
			center.x = size.x/2;
		
		handler.textBoxes.Push(self);
	}
	
	override void Execute(double fracTic)
	{
		center.y -= size.y / 2;
		
		size.y = 0;
		int fHeight = NewSmallFont.GetHeight();
		
		int scaledFH = fHeight * textScale;
		let lines = NewSmallFont.BreakLines(text, size.x/textScale);
		for (int i = 0; i < lines.Count(); ++i)
			size.y += scaledFH;
		
		center.y += size.y / 2;
		
		if (center.y + size.y/2 > 1080)
			center.y = 1080 - size.y/2;
		else if (center.y - size.y/2 < 0)
			center.y = size.y/2;
		
		super.Execute(fracTic);
		
		PreDraw(fracTic);
		
		int hOfs;
		for (uint i = 0; i < lines.Count(); ++i)
		{
			let line = lines.StringAt(i);
			DrawText(NewSmallFont, Font.CR_UNTRANSLATED, (scaledCenter.x-scaledSize.x/2, scaledCenter.y-scaledSize.y/2), line, (0,hOfs), textScale);
			hOfs += fHeight;
		}
		
		PostDraw(fracTic);
	}
	
	virtual void PreDraw(double fracTic) {}
	
	virtual void PostDraw(double fracTic)
	{
		Screen.DrawFrame(scaledCenter.x-scaledSize.x/2, scaledCenter.y-scaledSize.y/2, scaledSize.x, scaledSize.y);
	}
	
	override void OnDestroy()
	{
		handler.textBoxes.Delete(handler.textBoxes.Find(self));
		
		super.OnDestroy();
	}
}

class ItemCanvas : MenuElement
{
	private int curItem;
	int maxItemsRow;
	Vector2 offset;
	Vector2 defaultPos;
	Vector2 pos;
	
	uint Find(Inventory item)
	{
		uint i;
		for (; i < children.Size(); ++i)
		{
			let child = ItemBox(children[i]);
			if (!child)
				continue;
			
			if (child.item == item)
				return i;
		}
		
		return i;
	}
	
	override void Initialize()
	{
		super.Initialize();
		
		bNoCollision = true;
		offset = (150,150);
		defaultPos = pos = (center.x - size.x/2 + 100, center.y - size.y/2 + 100);
		maxItemsRow = 7;
		bTile = true;
		backgroundDesaturation = 1;
		backgroundColor = 0x9F000000;
		background = TexMan.CheckForTexture("AUTOPAGE", TexMan.Type_Any);
		backgroundAlpha = 0.6;
	}
	
	override void Tick()
	{
		// Remove items no longer present
		for (uint i = 0; i < children.Size(); ++i)
		{
			let child = ItemBox(children[i]);
			if (!child || handler.items.Find(child.item) != handler.items.Size())
				continue;
			
			for (uint j = children.Size() - 1; j > i; --j)
			{
				let ib = ItemBox(children[j]);
				if (!ib)
					continue;
					
				for (; j > i; --j)
				{
					let previb = ItemBox(children[j-1]);
					if (previb)
					{
						ib.center = previb.center;
						break;
					}
				}
			}
			
			child.Destroy();
			children.Delete(i--);
			if (--curItem >= 0)
				pos.x -= offset.x;
			else
			{
				curItem = maxItemsRow - 1;
				pos.y -= offset.y;
				pos.x = defaultPos.x + offset.x*curItem;
			}
		}
		
		// Add new items
		for (uint i = 0; i < handler.items.Size(); ++i)
		{
			if (Find(handler.items[i]) != children.Size())
				continue;
			
			let ib = ItemBox(MenuElement.Create("ItemBox", handler, pos, (100,100), self));
			if (ib)
			{
				ib.item = handler.items[i];
				if (++curItem < maxItemsRow)
					pos.x += offset.x;
				else
				{
					curItem = 0;
					pos.x = defaultPos.x;
					pos.y += offset.y;
				}
			}
		}
		
		super.Tick();
	}
	
	override void Execute(double fracTic)
	{
		super.Execute(fracTic);
		
		if (handler.player)
		{
			int fH = NewSmallFont.GetHeight();
			String text = String.Format("%sWeight:%s %.1f / %.1f", Font.TEXTCOLOR_BOLD, Font.TEXTCOLOR_NORMAL, handler.player.currentCapacity/10., handler.player.carryCapacity/10.);
			DrawText(NewSmallFont, Font.CR_UNTRANSLATED, (scaledCenter.x-scaledSize.x/2, scaledCenter.y-scaledSize.y/2), text, (0,-fH), 2);
		}
		
		Screen.DrawFrame(scaledCenter.x-scaledSize.x/2, scaledCenter.y-scaledSize.y/2, scaledSize.x, scaledSize.y);
	}
}

class ItemBox : MenuElement
{
	Inventory item;
	TextBox text;
	
	bool bHighlighted;
	
	int leftClickTimer;
	int rightClickTimer;
	
	void Swap(ItemBox other)
	{
		if (!other || self == other)
			return;
		
		uint index = parent.children.Find(self);
		uint otherIndex = parent.children.Find(other);
		parent.children[otherIndex] = self;
		parent.children[index] = other;
		
		Vector2 temp = other.center;
		other.center = center;
		center = temp;
		
		if (!item || !other.item)
			return;
		
		string command = String.Format("swapitem:%s:%s", item.GetClassName(), other.item.GetClassName());
		EventHandler.SendNetworkEvent(command);
	}
	
	override void Tick()
	{
		super.Tick();
		
		bHighlighted = false;
		if (item == players[consoleplayer].mo.InvSel)
			bHighlighted = true;
	}
	
	override void Clear()
	{
		super.Clear();
		
		leftClickTimer = 0;
		rightClickTimer = 0;
	}
	
	override void OnHeld()
	{
		scaledCenter = handler.mouse;
		Screen.DrawFrame(scaledCenter.x-scaledSize.x/2, scaledCenter.y-scaledSize.y/2, scaledSize.x, scaledSize.y);
	}
	
	virtual void OnHighlighted()
	{
		Screen.DrawFrame(scaledCenter.x-scaledSize.x/2, scaledCenter.y-scaledSize.y/2, scaledSize.x, scaledSize.y);
	}
	
	override void OnHover()
	{
		if (!bSelected && !bHighlighted)
			Screen.DrawFrame(scaledCenter.x-scaledSize.x/2, scaledCenter.y-scaledSize.y/2, scaledSize.x, scaledSize.y);
		
		if (item)
		{
			string title = item.GetTag();
			int titleLength = NewSmallFont.StringWidth(title);
			int fHeight = NewSmallFont.GetHeight();
			
			DrawText(NewSmallFont, Font.CR_UNTRANSLATED, scaledCenter-(0,scaledSize.y/2), title, (-titleLength / 2, -fHeight), 2);
			
			if (!text)
				text = TextBox(MenuElement.Create("TextBox", handler, (center.x, center.y+size.y/2), (600,0)));
			
			let rpgi = RPGItem(item);
			if (rpgi && text)
				text.text = String.Format("%sWeight:%s %.1f\n%sTotal:%s %.1f\n\n%s", Font.TEXTCOLOR_BOLD, Font.TEXTCOLOR_NORMAL, rpgi.weight/10., Font.TEXTCOLOR_BOLD, Font.TEXTCOLOR_NORMAL, rpgi.weight*rpgi.amount/10., rpgi.description);
		}
		
		if (!bLeftClicked && !bRightClicked)
		{
			if (handler.buttonAction == BI_USE)
			{
				string use = "use:"..item.GetClassName();
				EventHandler.SendNetworkEvent(use);
			}
		}
	}
	
	override void Execute(double fracTic)
	{
		super.Execute(fracTic);
		
		if (!bHeld && !bSelected && bHighlighted)
			OnHighlighted();
		
		if (item)
		{
			DrawTexture(item.icon, scaledCenter, (2,2));
		
			if (!bHeld)
			{
				int fHeight = NewSmallFont.GetHeight();
				string amount = String.Format("%d", item.amount);
				int amtLength = NewSmallFont.StringWidth(amount);
				
				DrawText(NewSmallFont, Font.CR_UNTRANSLATED, scaledCenter+(scaledSize.x/2, scaledSize.y/2), amount, (-amtLength, -fHeight), 2);
			}
		}
		
		if (text && !bHovering)
			text.Destroy();
		
		if (leftClickTimer > 0)
			leftClickTimer -= deltatime;
	}
	
	override void OnLeftClick()
	{
		if (leftClickTimer > 0)
		{
			string use = "use:"..item.GetClassName();
			EventHandler.SendNetworkEvent(use);
			leftClickTimer = 0;
		}
	}
	
	override void OnLeftRelease()
	{
		if (item)
		{
			if (bHeld)
			{
				scaledCenter = handler.mouse;
				handler.UpdateCollision(self);
				let t = ItemBox(touching);
				if (t && t.parent == parent)
					Swap(t);
				
				bHeld = false;
			}
			else if (bLeftClicked)
			{
				players[consoleplayer].mo.InvSel = item;
				if (leftClickTimer <= 0)
					leftClickTimer = 250;
			}
		}
		
		holdTimer = 0;
	}
	
	override void OnLeftHold()
	{
		if (bLeftClicked)
		{
			if (holdTimer < 250)
				holdTimer += deltatime;
			else
				bHeld = true;
		}
	}
	
	override void OnRightHold()
	{
		if (bRightClicked)
		{
			if (rightClickTimer < 250)
				rightClickTimer += deltatime;
		}
	}
	
	override void OnRightRelease()
	{
		if (item)
		{
			string drop = "drop:"..item.GetClassName();
			
			if (rightClickTimer >= 250)
			{
				for (int i = 0; i < item.amount; ++i)
					EventHandler.SendNetworkEvent(drop);
			}
			else				
				EventHandler.SendNetworkEvent(drop);
		}
		
		rightClickTimer = 0;
	}
	
	override void OnDestroy()
	{
		if (text)
			text.Destroy();
		
		super.OnDestroy();
	}
}

class KeyItemCanvas : MenuElement
{
	private int curItem;
	int maxItemsRow;
	Vector2 offset;
	Vector2 defaultPos;
	Vector2 pos;
	
	uint Find(Inventory item)
	{
		uint i;
		for (; i < children.Size(); ++i)
		{
			let child = KeyItemBox(children[i]);
			if (!child)
				continue;
			
			if (child.item == item)
				return i;
		}
		
		return i;
	}
	
	override void Initialize()
	{
		super.Initialize();
		
		bNoCollision = true;
		offset = (150,150);
		defaultPos = pos = (center.x - size.x/2 + 100, center.y - size.y/2 + 100);
		maxItemsRow = 7;
		bTile = true;
		backgroundDesaturation = 1;
		backgroundColor = 0x9F000000;
		background = TexMan.CheckForTexture("AUTOPAGE", TexMan.Type_Any);
		backgroundAlpha = 0.6;
	}
	
	override void Tick()
	{
		// Remove items no longer present
		for (uint i = 0; i < children.Size(); ++i)
		{
			let child = KeyItemBox(children[i]);
			if (!child || handler.keyItems.Find(child.item) != handler.keyItems.Size())
				continue;
			
			for (uint j = children.Size() - 1; j > i; --j)
			{
				let ib = KeyItemBox(children[j]);
				if (!ib)
					continue;
					
				for (; j > i; --j)
				{
					let previb = KeyItemBox(children[j-1]);
					if (previb)
					{
						ib.center = previb.center;
						break;
					}
				}
			}
			
			child.Destroy();
			children.Delete(i--);
			if (--curItem >= 0)
				pos.x -= offset.x;
			else
			{
				curItem = maxItemsRow - 1;
				pos.y -= offset.y;
				pos.x = defaultPos.x + offset.x*curItem;
			}
		}
		
		// Add new items
		for (uint i = 0; i < handler.keyItems.Size(); ++i)
		{
			if (Find(handler.keyItems[i]) != children.Size())
				continue;
			
			let ib = KeyItemBox(MenuElement.Create("KeyItemBox", handler, pos, (100,100), self));
			if (ib)
			{
				ib.item = handler.keyItems[i];
				if (++curItem < maxItemsRow)
					pos.x += offset.x;
				else
				{
					curItem = 0;
					pos.x = defaultPos.x;
					pos.y += offset.y;
				}
			}
		}
		
		super.Tick();
	}
	
	override void Execute(double ticFrac)
	{
		super.Execute(ticFrac);
		
		Screen.DrawFrame(scaledCenter.x-scaledSize.x/2, scaledCenter.y-scaledSize.y/2, scaledSize.x, scaledSize.y);
	}
}

class KeyItemBox : MenuElement
{
	Inventory item;
	
	void Swap(KeyItemBox other)
	{
		if (!other || self == other)
			return;
		
		uint index = parent.children.Find(self);
		uint otherIndex = parent.children.Find(other);
		parent.children[otherIndex] = self;
		parent.children[index] = other;
		
		Vector2 temp = other.center;
		other.center = center;
		center = temp;
		
		if (!item || !other.item)
			return;
		
		string command = String.Format("swapitem:%s:%s", item.GetClassName(), other.item.GetClassName());
		EventHandler.SendNetworkEvent(command);
	}
	
	override void OnHeld()
	{
		scaledCenter = handler.mouse;
		Screen.DrawFrame(scaledCenter.x-scaledSize.x/2, scaledCenter.y-scaledSize.y/2, scaledSize.x, scaledSize.y);
	}
	
	override void OnHover()
	{
		Screen.DrawFrame(scaledCenter.x-scaledSize.x/2, scaledCenter.y-scaledSize.y/2, scaledSize.x, scaledSize.y);
		
		if (item)
		{
			string title = item.GetTag();
			int titleLength = NewSmallFont.StringWidth(title);
			int fHeight = NewSmallFont.GetHeight();
			
			DrawText(NewSmallFont, Font.CR_UNTRANSLATED, scaledCenter-(0,scaledSize.y/2), title, (-titleLength / 2, -fHeight), 2);
		}
	}
	
	override void Execute(double fracTic)
	{
		super.Execute(fracTic);
		
		if (item)
		{
			DrawTexture(item.icon, scaledCenter, (2,2));
		
			if (!bHeld)
			{
				int fHeight = NewSmallFont.GetHeight();
				string amount = String.Format("%d", item.amount);
				int amtLength = NewSmallFont.StringWidth(amount);
				
				DrawText(NewSmallFont, Font.CR_UNTRANSLATED, scaledCenter+(scaledSize.x/2, scaledSize.y/2), amount, (-amtLength, -fHeight), 2);
			}
		}
	}
	
	override void OnLeftRelease()
	{
		if (item && bHeld)
		{
			scaledCenter = handler.mouse;
			handler.UpdateCollision(self);
			let t = KeyItemBox(touching);
			if (t && t.parent == parent)
				Swap(t);
				
			bHeld = false;
		}
		
		holdTimer = 0;
	}
	
	override void OnLeftHold()
	{
		if (bLeftClicked)
		{
			if (holdTimer < 250)
				holdTimer += deltatime;
			else
				bHeld = true;
		}
	}
}

class ArmorBox : MenuElement
{
	enum EArmorTypes
	{
		AT_HEAD = 1,
		AT_AMUL,
		AT_CHEST,
		AT_BRACE,
		AT_SHIELD
	}
	
	TextBox text;
	Inventory armor;
	int type;
	
	override void Initialize()
	{
		super.Initialize();
		
		background = TexMan.CheckForTexture("ARTIBOX", TexMan.Type_Any);
		backgroundAlpha = 0.6;
		bNoCollision = true;
	}
	
	override void Tick()
	{
		if (!armor)
		{
			if (text)
				text.Destroy();
			
			switch (type)
			{
				case AT_HEAD:
					armor = players[consoleplayer].mo.FindInventory("HelmetPiece");
					break;
					
				case AT_AMUL:
					armor = players[consoleplayer].mo.FindInventory("AmuletPiece");
					break;
					
				case AT_CHEST:
					armor = players[consoleplayer].mo.FindInventory("ChestPiece");
					break;
					
				case AT_BRACE:
					armor = players[consoleplayer].mo.FindInventory("BracerPiece");
					break;
					
				case AT_SHIELD:
					armor = players[consoleplayer].mo.FindInventory("ShieldPiece");
					break;
			}
		}
		else if (armor.owner != players[consoleplayer].mo)
			armor = null;
		
		super.Tick();
	}
	
	override void Execute(double fracTic)
	{
		super.Execute(fracTic);
		
		if (armor)
		{
			double ratio = (1 - armor.health*1. / armor.default.health) * 0.8;
			int alpha = int(0xFF * ratio) << 24;
			int col = alpha | 0x00FF0000;
			
			DrawTexture(armor.icon, scaledCenter, (2.25,2.25), color: col);
		}
		
		if (text && !bHovering)
			text.Destroy();
	}
	
	override void OnHover()
	{
		if (!armor)
			return;
		
		if (!text)
			text = TextBox(MenuElement.Create("TextBox", handler, (center.x, center.y+size.y/2), (600,0)));
		
		if (text)
		{
			text.text = String.Format("%sDurability:%s %d / %d\n\n", Font.TEXTCOLOR_BOLD, Font.TEXTCOLOR_NORMAL, armor.health, armor.default.health);
			let ar = ArmorPiece(armor);
			if (ar)
				text.text.AppendFormat("%s", ar.description);
		}
	}
	
	override void OnDestroy()
	{
		if (text)
			text.Destroy();
		
		super.OnDestroy();
	}
}

class StatCanvas : MenuElement
{
	MenuElement button;
	double hOffset;
	Vector2 pos;
	
	override void Initialize()
	{
		super.Initialize();
		
		hOffset = 125;
		pos = (center.x, center.y - size.y/2 + hOffset/2);
		bNoCollision = true;
		bTile = true;
		backgroundDesaturation = 1;
		backgroundColor = 0x9F000000;
		background = TexMan.CheckForTexture("AUTOPAGE", TexMan.Type_Any);
		backgroundAlpha = 0.6;
	}
	
	uint Find(Stat st)
	{
		uint i;
		for (; i < children.Size(); ++i)
		{
			let child = StatBox(children[i]);
			if (!child)
				continue;
			
			if (child.st == st)
				return i;
		}
		
		return i;
	}
	
	override void Tick()
	{
		// Remove stats no longer present
		for (uint i = 0; i < children.Size(); ++i)
		{
			let child = StatBox(children[i]);
			if (!child || handler.stats.Find(child.st) != handler.stats.Size())
				continue;
			
			for (uint j = children.Size() - 1; j > i; --j)
			{
				let sb = StatBox(children[j]);
				if (!sb)
					continue;
					
				for (; j > i; --j)
				{
					let prevsb = StatBox(children[j-1]);
					if (prevsb)
					{
						sb.Shift(sb.center - prevsb.center);
						break;
					}
				}
			}
			
			child.Destroy();
			children.Delete(i--);
			if (children.Size())
				pos.y -= hOffset;
		}
		
		// Add new stats
		for (uint i = 0; i < handler.stats.Size(); ++i)
		{
			if (Find(handler.stats[i]) != children.Size())
				continue;
			
			let sb = StatBox(MenuElement.Create("StatBox", handler, pos, (size.x,hOffset), self));
			if (sb)
			{
				sb.st = handler.stats[i];
				sb.st.currentLevel = sb.st.level;
				sb.st.currentCost = 0;
				if (sb.description)
					sb.description.text = Font.TEXTCOLOR_BOLD..sb.st.GetTag()..Font.TEXTCOLOR_NORMAL.."\n"..sb.st.description;
				
				pos.y += hOffset;
			}
		}
		
		super.Tick();
	}
	
	override void Execute(double fracTic)
	{
		super.Execute(fracTic);
		
		Screen.DrawFrame(scaledCenter.x-scaledSize.x/2, scaledCenter.y-scaledSize.y/2, scaledSize.x, scaledSize.y);
		
		int fHeight = NewSmallFont.GetHeight();
		
		if (handler.totalCost > 0)
		{
			String col = Font.TEXTCOLOR_NORMAL;
			if (handler.player && handler.totalCost > handler.player.currentXP)
				col = Font.TEXTCOLOR_RED;
			
			String text = String.Format("XP Required: %s%d", col, handler.totalCost);
			int length = NewSmallFont.StringWidth(text);
			DrawText(NewSmallFont, Font.CR_UNTRANSLATED, (scaledCenter.x, scaledCenter.y-scaledSize.y/2), text, (-length/2, -fHeight), 2);
		}
		
		if (handler.player)
		{
			DrawText(NewSmallFont, Font.CR_UNTRANSLATED, (scaledCenter.x-scaledSize.x/2, scaledCenter.y-scaledSize.y/2), String.Format("Level %d", handler.player.currentLevel), (0, -fHeight*2), 2);
			DrawText(NewSmallFont, Font.CR_UNTRANSLATED, (scaledCenter.x-scaledSize.x/2, scaledCenter.y-scaledSize.y/2), String.Format("%d / %d XP", handler.player.currentXP, handler.player.nextLevelXP), (0, -fHeight), 2);
			
			if (handler.player.currentPoints != handler.player.points || handler.totalCost > 0)
			{
				if (!button)
					button = MenuElement.Create("ConfirmButton", handler, (center.x, center.y+size.y/2+50), (200,100), self);
			}
			else if (button)
				button.Destroy();
		}
	}
	
	override void OnDestroy()
	{
		if (button)
			button.Destroy();
		
		super.OnDestroy();
	}
}

class StatBox : MenuElement
{
	Stat st;
	StatTextBox description;
	StatTextBox bonus;
	
	override void Initialize()
	{
		super.Initialize();
		
		bNoCollision = true;
		MenuElement.Create("StatIncrementer", handler, (center.x-size.x/2 + 50, center.y), (100,100), self);
		MenuElement.Create("LevelDisplay", handler, (center.x-size.x/2 + 150, center.y), (100,100), self);
		MenuElement.Create("StatDecrementer", handler, (center.x-size.x/2 + 250, center.y), (100,100), self);
		description = StatTextBox(MenuElement.Create("StatTextBox", handler, (center.x-size.x/2 + 650, center.y), (600, 100)));
		bonus = StatTextBox(MenuElement.Create("StatTextBox", handler, (center.x-size.x/2 + 1125, center.y), (300, 100)));
	}
	
	override void Execute(double fracTic)
	{
		super.Execute(fracTic);
		
		if (st && bonus)
		{
			String text = Font.TEXTCOLOR_BOLD.."Bonus\n"..Font.TEXTCOLOR_NORMAL;
			
			if (st.currentLevel > 1)
			{
				for (uint i = 0; i < st.bonusValue.Size(); ++i)
				{
					int val = st.bonusValue[i] * (st.currentLevel - 1);
					if (val > 0)
						text.AppendFormat("+");
					
					text.AppendFormat("%d%s", val, st.bonusText[i]);
				}
			}
			
			bonus.text = text;
		}
	}
	
	override void OnDestroy()
	{
		if (description)
			description.Destroy();
		
		if (bonus)
			bonus.Destroy();
		
		super.OnDestroy();
	}
}

class StatIncrementer : MenuElement
{
	override void Initialize()
	{
		super.Initialize();
		
		bNoCollision = true;
	}
	
	override void OnHover()
	{
		Screen.DrawFrame(scaledCenter.x-scaledSize.x/2, scaledCenter.y-scaledSize.y/2, scaledSize.x, scaledSize.y);
	}
	
	override void Execute(double fracTic)
	{
		super.Execute(fracTic);
		
		let st = StatBox(parent).st;
		if (!st)
			return;
		
		int fHeight = NewSmallFont.GetHeight() / 2;
		int width = NewSmallFont.StringWidth("+") / 2;
		
		DrawText(NewSmallFont, Font.CR_UNTRANSLATED, scaledCenter, "+", (-width, -fHeight), 3);
	}
	
	override void OnLeftRelease()
	{
		let st = StatBox(parent).st;
		if (!st || !handler.player)
			return;
		
		if (st.currentLevel < st.maxLevel && handler.player.currentPoints > 0)
		{
			++st.currentLevel;
			--handler.player.currentPoints;
			if (st.currentLevel <= st.level)
				st.currentCost -= st.cost;
		}
	}
}

class StatDecrementer : MenuElement
{
	override void Initialize()
	{
		super.Initialize();
		
		bNoCollision = true;
	}
	
	override void OnHover()
	{
		Screen.DrawFrame(scaledCenter.x-scaledSize.x/2, scaledCenter.y-scaledSize.y/2, scaledSize.x, scaledSize.y);
	}
	
	override void Execute(double fracTic)
	{
		super.Execute(fracTic);
		
		let st = StatBox(parent).st;
		if (!st)
			return;
		
		int fHeight = NewSmallFont.GetHeight() / 2;
		int width = NewSmallFont.StringWidth("+") / 2;
		
		DrawText(NewSmallFont, Font.CR_UNTRANSLATED, scaledCenter, "-", (-width, -fHeight), 3);
	}
	
	override void OnLeftRelease()
	{
		let st = StatBox(parent).st;
		if (!st || !handler.player)
			return;
		
		if (st.currentLevel > st.minLevel)
		{
			--st.currentLevel;
			++handler.player.currentPoints;
			if (st.currentLevel < st.level)
				st.currentCost += st.cost;
		}
	}
}

class LevelDisplay : MenuElement
{
	ui int oldLevel;
	
	override void Initialize()
	{
		super.Initialize();
		
		bNoCollision = true;
	}
	
	override void Tick()
	{
		let st = StatBox(parent).st;
		if (st)
		{
			if (oldLevel != st.level)
				st.currentLevel = st.level;
			
			oldLevel = st.level;
		}
		
		super.Tick();
	}
	
	override void Execute(double fracTic)
	{
		super.Execute(fracTic);
		
		let st = StatBox(parent).st;
		if (!st)
			return;
		
		int col = Font.CR_UNTRANSLATED;
		if (st.currentLevel < st.level)
			col = Font.CR_RED;
		else if (st.currentLevel > st.level)
			col = Font.CR_GREEN;
		
		String num = String.Format("%d", st.currentLevel);
		int fHeight = NewSmallFont.GetHeight() / 2;
		int width = NewSmallFont.StringWidth(num) / 2;
		
		DrawText(NewSmallFont, col, scaledCenter, num, (-width, -fHeight), 3);
	}
}

class StatTextBox : TextBox
{
	override void Initialize()
	{
		super.Initialize();
		
		background.SetInvalid();
		textScale = 1.5;
	}
	
	override void PostDraw(double fracTic) {}
}

class ConfirmButton : MenuElement
{
	override void OnHover()
	{
		Screen.DrawFrame(scaledCenter.x-scaledSize.x/2, scaledCenter.y-scaledSize.y/2, scaledSize.x, scaledSize.y);
	}
	
	override void Execute(double fracTic)
	{
		super.Execute(fracTic);
		
		int fHeight = NewSmallFont.GetHeight();
		String con = "Confirm";
		int length = NewSmallFont.StringWidth(con);
		
		DrawText(NewSmallFont, Font.CR_UNTRANSLATED, scaledCenter, con, (-length/2, -fHeight/2), 2);
	}
	
	override void OnLeftRelease()
	{
		handler.LevelPlayer();
	}
}

class SkillBox : MenuElement
{
	Skill sk;
	SkillPage sp;
	uint slot;
	bool bCreated;
	TextBox text;
	
	override void Initialize()
	{
		super.Initialize();
		
		bNoCollision = true;
		background = TexMan.CheckForTexture("ARTIBOX", TexMan.Type_Any);
	}
	
	override void Execute(double fracTic)
	{
		super.Execute(fracTic);
		
		if (text && (!bHovering || !sk))
			text.Destroy();
		
		if (handler.player && slot < handler.player.skillSlots)
			sk = handler.player.activeSkills[slot];
		
		if (sk)
			DrawTexture(sk.icon, scaledCenter, (3,3));
		
		if (!bCreated && sp && handler.mouseAction == MI_LEFTRELEASE)
		{
			double sw = sp.scaledSize.x/2;
			double sh = sp.scaledSize.y/2;
			
			if (handler.mouse.x < (sp.scaledCenter.x-sw) || handler.mouse.x > (sp.scaledCenter.x+sw) ||
				handler.mouse.y < (sp.scaledCenter.y-sh) || handler.mouse.y > (sp.scaledCenter.y+sh))
			{
				sp.Destroy();
			}
		}
		
		bCreated = false;
	}
	
	override void OnHover()
	{
		Screen.DrawFrame(scaledCenter.x-scaledSize.x/2, scaledCenter.y-scaledSize.y/2, scaledSize.x, scaledSize.y);
		
		if (!sk)
			return;
		
		if (!text)
		{
			text = TextBox(MenuElement.Create("TextBox", handler, (center.x, center.y+size.y/2), (600,0)));
			text.text = Font.TEXTCOLOR_BOLD..sk.GetTag()..Font.TEXTCOLOR_NORMAL.."\n\n"..sk.description;
		}
	}
	
	override void OnLeftRelease()
	{
		if (!sp)
		{
			bCreated = true;
			sp = SkillPage(MenuElement.Create("SkillPage", handler, center-(0,size.y/2+150), (300,300), self));
			sp.slot = slot;
			return;
		}
	}
	
	override void OnDestroy()
	{
		if (text)
			text.Destroy();
		
		super.OnDestroy();
	}
}

class SkillPage : MenuElement
{
	private int curItem;
	int maxItemsRow;
	Vector2 offset;
	Vector2 defaultPos;
	Vector2 pos;
	uint slot;
	
	bool bKill;
	
	uint Find(Skill sk)
	{
		uint i;
		for (; i < children.Size(); ++i)
		{
			let child = SkillSelect(children[i]);
			if (!child)
				continue;
			
			if (child.sk == sk)
				return i;
		}
		
		return i;
	}
	
	override void Initialize()
	{
		super.Initialize();
		
		bTile = true;
		backgroundDesaturation = 1;
		backgroundColor = 0x9F000000;
		background = TexMan.CheckForTexture("AUTOPAGE", TexMan.Type_Any);
		backgroundAlpha = 0.6;
		bNoCollision = true;
		offset = (100,100);
		defaultPos = pos = (center.x - size.x/2+50, center.y - size.y/2 + 50);
		maxItemsRow = 3;
		
		MenuElement.Create("SkillSelect", handler, pos, (100,100), self);
		if (++curItem < maxItemsRow)
			pos.x += offset.x;
		else
		{
			curItem = 0;
			pos.x = defaultPos.x;
			pos.y += offset.y;
		}
	}
	
	override void Tick()
	{
		// Remove skills no longer present
		for (uint i = 1; i < children.Size(); ++i)
		{
			let child = SkillSelect(children[i]);
			if (!child || handler.skills.Find(child.sk) != handler.skills.Size())
				continue;
			
			for (uint j = children.Size() - 1; j > i; --j)
			{
				let sb = SkillSelect(children[j]);
				if (!sb)
					continue;
					
				for (; j > i; --j)
				{
					let prevsb = SkillSelect(children[j-1]);
					if (prevsb)
					{
						sb.Shift(sb.center - prevsb.center);
						break;
					}
				}
			}
			
			child.Destroy();
			children.Delete(i--);
			if (--curItem >= 0)
				pos.x -= offset.x;
			else
			{
				curItem = maxItemsRow - 1;
				pos.y -= offset.y;
				pos.x = defaultPos.x + offset.x*curItem;
			}
		}
		
		// Add new skills
		let par = SkillBox(parent);
		for (uint i = 0; i < handler.skills.Size(); ++i)
		{
			if (handler.skills[i] == par.sk || Find(handler.skills[i]) != children.Size())
				continue;
			
			let sb = SkillSelect(MenuElement.Create("SkillSelect", handler, pos, (100,100), self));
			if (sb)
			{
				sb.sk = handler.skills[i];
				if (++curItem < maxItemsRow)
					pos.x += offset.x;
				else
				{
					curItem = 0;
					pos.x = defaultPos.x;
					pos.y += offset.y;
				}
			}
		}
		
		super.Tick();
	}
	
	override void Execute(double fracTic)
	{
		super.Execute(fracTic);
		
		if (bKill)
		{
			Destroy();
			return;
		}
		
		Screen.DrawFrame(scaledCenter.x-scaledSize.x/2, scaledCenter.y-scaledSize.y/2, scaledSize.x, scaledSize.y);
	}
}

class SkillSelect : MenuElement
{
	Skill sk;
	TextBox text;
	
	override void Initialize()
	{
		super.Initialize();
		
		bNoCollision = true;
		background = TexMan.CheckForTexture("ARTIBOX", TexMan.Type_Any);
	}
	
	override void Execute(double fracTic)
	{
		super.Execute(fracTic);
		
		if (text && !bHovering)
			text.Destroy();
		
		if (sk)
			DrawTexture(sk.icon, scaledCenter, (2.5,2.5));
	}
	
	override void OnHover()
	{
		Screen.DrawFrame(scaledCenter.x-scaledSize.x/2, scaledCenter.y-scaledSize.y/2, scaledSize.x, scaledSize.y);
		
		if (!text)
		{
			text = TextBox(MenuElement.Create("TextBox", handler, (center.x, center.y+size.y/2), (600,0)));
			
			if (sk)
				text.text = Font.TEXTCOLOR_BOLD..sk.GetTag()..Font.TEXTCOLOR_NORMAL.."\n\n"..sk.description;
			else
				text.text = "Remove spell from slot";
		}
	}
	
	override void OnLeftRelease()
	{
		let par = SkillPage(parent);
		if (!par)
			return;
		
		String command = "swapskill:";
		if (sk)
			command.AppendFormat("%s", sk.GetClassName());
		else
			command.AppendFormat("null");
		
		EventHandler.SendNetworkEvent(command, par.slot);
		
		par.bKill = true;
	}
	
	override void OnDestroy()
	{
		if (text)
			text.Destroy();
		
		super.OnDestroy();
	}
}

class KeyCanvas : MenuElement
{
	Vector2 offset;
	Vector2 pos;
	
	uint Find(Inventory key)
	{
		uint i;
		for (; i < children.Size(); ++i)
		{
			let child = KeyBox(children[i]);
			if (!child)
				continue;
			
			if (child.key == key)
				return i;
		}
		
		return i;
	}
	
	override void Initialize()
	{
		super.Initialize();
		
		bNoCollision = true;
		offset = (49.5,87);
		pos = (center.x - size.x/2 + 24.5, center.y - size.y/2 + 43.5);
		background = TexMan.CheckForTexture("KEYBAR2", TexMan.Type_Any);
		backgroundScale = 2.5;
		bTile = true;
	}
	
	override void Tick()
	{
		// Remove keys no longer present
		for (uint i = 0; i < children.Size(); ++i)
		{
			let child = KeyBox(children[i]);
			if (!child || handler.keys.Find(child.key) != handler.keys.Size())
				continue;
			
			for (uint j = children.Size() - 1; j > i; --j)
			{
				let ib = KeyBox(children[j]);
				if (!ib)
					continue;
					
				for (; j > i; --j)
				{
					let previb = KeyBox(children[j-1]);
					if (previb)
					{
						ib.center = previb.center;
						break;
					}
				}
			}
			
			child.Destroy();
			children.Delete(i--);
			pos.x -= offset.x;
		}
		
		// Add new keys
		for (uint i = 0; i < handler.keys.Size(); ++i)
		{
			if (Find(handler.keys[i]) != children.Size())
				continue;
			
			let ib = KeyBox(MenuElement.Create("KeyBox", handler, pos, (47,87), self));
			if (ib)
			{
				ib.key = handler.keys[i];
				pos.x += offset.x;
			}
		}
		
		super.Tick();
	}
}

class KeyBox : MenuElement
{
	Inventory key;
	
	override void Initialize()
	{
		super.Initialize();
		
		bNoCollision = true;
	}
	
	override void Execute(double fracTic)
	{
		super.Execute(fracTic);
		
		if (key)
			DrawTexture(key.icon, scaledCenter, (2.5,2.5));
	}
	
	override void OnHover()
	{
		if (key)
		{
			String tag = key.GetTag();
			String modName = tag.Mid(3).." "..tag.Left(3);
			int fH = NewSmallFont.GetHeight();
			int length = NewSmallFont.StringWidth(modName);
			DrawText(NewSmallFont, Font.CR_UNTRANSLATED, (scaledCenter.x, scaledCenter.y - scaledSize.y/2), modName, (-length/2,-fH), 2);
		}
	}
}

enum EWeaponTypes
{
	WT_WRAI = 1,
	WT_PURI,
	WT_ZWEI
}

class WeaponPieceCanvas : MenuElement
{
	Array<PieceBox> pieces;
	class<Weapon> weap;
	TextureID weapon;
	TextureID full;
	
	bool bDrawFull;
	
	void SetWeapon(int w)
	{
		for (uint i = 0; i < pieces.Size(); ++i)
		{
			if (pieces[i])
				pieces[i].Destroy();
		}
		pieces.Clear();
		
		String tex = "WPIECE";
		switch (w)
		{
			case WT_WRAI:
				weapon = TexMan.CheckForTexture("WPSLOT2", TexMan.Type_Any);
				full = TexMan.CheckForTexture("WPFULL2", TexMan.Type_Any);
				weap = "MWeapBloodscourge";
				tex = tex.."M";
				break;
					
			case WT_PURI:
				weapon = TexMan.CheckForTexture("WPSLOT1", TexMan.Type_Any);
				full = TexMan.CheckForTexture("WPFULL1", TexMan.Type_Any);
				weap = "CWeapWraithverge";
				tex = tex.."C";
				break;
				
			case WT_ZWEI:
				weapon = TexMan.CheckForTexture("WPSLOT0", TexMan.Type_Any);
				full = TexMan.CheckForTexture("WPFULL0", TexMan.Type_Any);
				weap = "ReforgedQuietus";
				tex = tex.."F";
				break;
		}
		
		double ofs;
		for (uint i = 1; i < 4; ++i)
		{
			let pb = PieceBox(MenuElement.Create("PieceBox", handler, center, size, self));
			if (pb)
			{
				pb.part = TexMan.CheckForTexture(tex..i, TexMan.Type_Any);
				ofs = pb.SetPos(i, ofs);
				pieces.Push(pb);
			}
		}
	}
	
	int GetWeaponPieceMask()
	{
		for (let inv = players[consoleplayer].mo.inv; inv; inv = inv.inv)
		{
			let wh = WeaponHolder(inv);
			if (wh && wh.PieceWeapon == weap)
				return wh.PieceMask;
		}
		
		return 0;
	}
	
	override void Initialize()
	{
		super.Initialize();
		
		bNoCollision = true;
	}
	
	override void Tick()
	{
		super.Tick();
		
		bDrawFull = (players[consoleplayer].mo.FindInventory(weap) != null);
		if (!bDrawfull)
		{
			int mask = GetWeaponPieceMask();
			if (mask & 1)
				pieces[0].bDraw = true;
			if (mask & 2)
				pieces[1].bDraw = true;
			if (mask & 4)
				pieces[2].bDraw = true;
		}
	}
	
	override void PreChild(double fracTic)
	{
		if (bDrawFull)
			DrawTexture(full, scaledCenter, (3,3));
		else
			DrawTexture(weapon, scaledCenter, (3,3));
	}
}

class PieceBox : MenuElement
{
	TextureID part;
	bool bDraw;
	
	double SetPos(int slot, double offset)
	{
		Vector2 s = TexMan.GetScaledSize(part);
		s *= 3;
		
		switch (slot)
		{
			case 1:
				center.x = center.x - size.x/2 + s.x/2;
				break;
				
			case 2:
				center.x = center.x - size.x/2 + offset + s.x/2;
				break;
				
			case 3:
				center.x = center.x + size.x/2 - s.x/2;
				break;
		}
		
		size.x = s.x;
		return s.x;
	}
	
	override void Initialize()
	{
		super.Initialize();
		
		bNoCollision = true;
	}
	
	override void Tick()
	{
		super.Tick();
		
		bDraw = false;
	}
	
	override void Execute(double fracTic)
	{
		super.Execute(fracTic);
		
		if (bDraw)
			DrawTexture(part, scaledCenter, (3,3));
	}
}