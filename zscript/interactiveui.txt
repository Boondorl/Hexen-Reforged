class MenuElement : Object ui
{
	MenuHandler handler;
	MenuElement parent;
	Array<MenuElement> children;
	MenuElement touching;
	
	TextureID background;
	double backgroundAlpha;
	
	int age;
	Vector2 size;
	Vector2 center;
	Vector2 tolerance;
	
	Vector2 scaledSize;
	Vector2 scaledCenter;
	Vector2 scaledTolerance;
	Vector2 scalar;
	
	int clip[4]; // Not currently used
	bool bKeepAspectRatio;
	bool bCenter;
	bool bInvisible;
	bool bNoCollision;
	
	bool bLeftClicked;
	bool bRightClicked;
	bool bSelected;
	bool bHeld;
	bool bHovering;
	
	protected int holdTimer;
	protected uint deltatime;
	private uint prevTime;
	
	static MenuElement Create(class<MenuElement> type, MenuHandler han, Vector2 pos, Vector2 size, MenuElement par = null)
	{
		let element = MenuElement(new(type));
		if (!element)
			return null;
		
		element.handler = han;
		element.center = pos;
		element.size = size;
		
		if (par)
		{
			element.parent = par;
			par.children.Push(element);
		}
		
		element.Initialize();
		
		return element;
	}
	
	void DrawTexture(TextureID texture, Vector2 pos, Vector2 scale = (1,1), double alpha = 1, int color = 0)
	{
		if (bInvisible || !scale.x || !scale.y)
			return;
			
		Vector2 size = TexMan.GetScaledSize(texture);
		size.y *= 1.2;
			
		size.x *= scale.x;
		size.y *= scale.y;
			
		if (bKeepAspectRatio)
			size *= min(scalar.x, scalar.y);
		else
		{
			size.x *= scalar.x;
			size.y *= scalar.y;
		}
			
		Screen.DrawTexture(texture, false, pos.x, pos.y,
							DTA_CenterOffset, true, DTA_DestWidth, int(size.x), DTA_DestHeight, int(size.y),
							DTA_Alpha, alpha, DTA_ColorOverlay, color);
	}
	
	void DrawText(Font fnt, int color, Vector2 pos, string text, Vector2 offset = (0,0), double scale = 1)
	{
		if (bInvisible || !scale)
			return;
		
		int vWidth = Screen.GetWidth();
		int vHeight = Screen.GetHeight();
		
		double ratio = min(scalar.x, scalar.y) * scale;
		vWidth /= ratio;
		vHeight /= ratio;
		
		offset *= ratio;
		
		pos.x += offset.x;
		pos.y += offset.y;
		
		pos /= ratio;
				
		Screen.DrawText(fnt, color, pos.x, pos.y, text,
						DTA_VirtualWidth, vWidth, DTA_VirtualHeight, vHeight, DTA_KeepRatio, true);
	}
	
	void CheckCollision(MenuElement other)
	{
		if (!other || self == other)
			return;
		
		if (!bNoCollision)
		{
			Vector2 orMin = (scaledCenter.x - scaledTolerance.x, scaledCenter.y - scaledTolerance.y);
			Vector2 orMax = (scaledCenter.x + scaledTolerance.x, scaledCenter.y + scaledTolerance.y);
			
			Vector2 otMin = (other.scaledCenter.x - other.scaledTolerance.x, other.scaledCenter.y - other.scaledTolerance.y);
			Vector2 otMax = (other.scaledCenter.x + other.scaledTolerance.x, other.scaledCenter.y + other.scaledTolerance.y);
			
			if ((orMin.x <= otMax.x && orMax.x >= otMin.x) &&
				(orMin.y <= otMax.y && orMax.y >= otMin.y))
			{
				if (!other.touching)
					other.touching = self;
				else
				{
					if (other.DistanceToSquared(touching) > other.DistanceToSquared(self))
						other.touching = self;
				}
			}
		}
		
		for (uint i = 0; i < children.Size(); ++i)
		{
			if (children[i])
				children[i].CheckCollision(other);
		}
	}
	
	double DistanceTo(MenuElement other)
	{
		if (!other)
			return double.max;
		
		return (other.scaledCenter - scaledCenter).Length();
	}
	
	double DistanceToSquared(MenuElement other)
	{
		if (!other)
			return double.max;
		
		Vector2 temp = other.scaledCenter - scaledCenter;
		return (temp dot temp);
	}
	
	void Shift(Vector2 diff)
	{
		center += diff;
		for (uint i = 0; i < children.Size(); ++i)
		{
			if (children[i])
				children[i].Shift(diff);
		}
	}
	
	virtual void Initialize()
	{
		bCenter = true;
		bKeepAspectRatio = true;
		tolerance = (size.x / 2, size.y / 2);
		backgroundAlpha = 1;
	}
	
	virtual void Clear()
	{
		bLeftClicked = false;
		bRightClicked = false;
		bSelected = false;
		bHeld = false;
		holdTimer = 0;
	}
	
	virtual void OnHover() {}
	
	virtual void OnHeld() {}
	
	virtual void OnSelected() {}
	
	virtual void OnLeftClick() {}
	
	virtual void OnRightClick() {}
	
	virtual void OnLeftHold() {}
	
	virtual void OnRightHold() {}
	
	virtual void OnLeftRelease() {}
	
	virtual void OnRightRelease() {}
	
	virtual void Tick()
	{
		++age;
		for (uint i = 0; i < children.Size(); ++i)
		{
			if (children[i])
				children[i].Tick();
		}
	}
	
	virtual void Execute(double fracTic)
	{
		uint currentTime = MSTime();
		if (!prevTime)
			prevTime = currentTime;
		
		deltatime = currentTime - prevTime;
		if (deltaTime > 200) // Cap to a minimum of 5 FPS
			deltaTime = 200;
		
		prevTime = currentTime;
		
		touching = null;
		bHovering = false;
		
		int wOfs, hOfs, w, h;
		[wOfs, hOfs, w, h] = Screen.GetViewWindow();
		
		scalar.x = w / 1920.;
		scalar.y = h / 1080.;
		
		if (bKeepAspectRatio)
		{
			double ratio = min(scalar.x, scalar.y);
			
			scaledSize = size * ratio;
			scaledTolerance = tolerance * ratio;
		}
		else
		{
			scaledSize.x = size.x * scalar.x;
			scaledSize.y = size.y * scalar.y;
			
			scaledTolerance.x = tolerance.x * scalar.x;
			scaledTolerance.y = tolerance.y * scalar.y;
		}
		
		if (bCenter)
		{
			double ratio = min(scalar.x, scalar.y);
			scaledCenter.x = wOfs + center.x*ratio + abs(1920*ratio - 1920*scalar.x)/2;
			scaledCenter.y = hOfs + center.y*ratio + abs(1080*ratio - 1080*scalar.y)/2;
		}
		else
		{
			scaledCenter.x = wOfs + center.x * scalar.x;
			scaledCenter.y = hOfs + center.y * scalar.y;
		}
		
		if (background.IsValid())
			Screen.DrawTexture(background, true, scaledCenter.x, scaledCenter.y,
								DTA_CenterOffset, true, DTA_DestWidth, int(scaledSize.x), DTA_DestHeight, int(scaledSize.y), DTA_Alpha, backgroundAlpha);
		
		double sw = scaledSize.x / 2;
		double sh = scaledSize.y / 2;
			
		if (bHeld ||
			(handler.mouse.x >= (scaledCenter.x-sw) && handler.mouse.x <= (scaledCenter.x+sw) &&
			handler.mouse.y >= (scaledCenter.y-sh) && handler.mouse.y <= (scaledCenter.y+sh)))
		{
			switch (handler.mouseAction)
			{
				case MI_LEFTPRESS:
					bLeftClicked = true;
					OnLeftClick();
					break;
						
				case MI_LEFTHOLD:
					OnLeftHold();
					break;
						
				case MI_LEFTRELEASE:
					OnLeftRelease();
					bLeftClicked = false;
					break;
						
				case MI_RIGHTPRESS:
					bRightClicked = true;
					OnRightClick();
					break;
						
				case MI_RIGHTHOLD:
					OnRightHold();
					break;
						
				case MI_RIGHTRELEASE:
					OnRightRelease();
					bRightClicked = false;
					break;
			}
				
			if (bHeld)
				OnHeld();
			else
			{
				bHovering = true;
				OnHover();
			}
		}
		else
		{
			holdTimer = 0;
			bLeftClicked = false;
			bRightClicked = false;
		}
		
		if (!bHeld && bSelected)
			OnSelected();
		
		for (uint i = 0; i < children.Size(); ++i)
		{
			if (children[i])
				children[i].Execute(fracTic);
		}
	}
	
	override void OnDestroy()
	{
		for (uint i = 0; i < children.Size(); ++i)
		{
			if (children[i])
				children[i].Destroy();
		}
		
		super.OnDestroy();
	}
}

class TextBox : MenuElement
{
	String text;
	double textScale;
	
	override void Initialize()
	{
		super.Initialize();
		
		background = TexMan.CheckForTexture("AUTOPAGE", TexMan.Type_Any);
		textScale = 1;
		bNoCollision = true;
		
		if (center.x + size.x/2 > 1920)
			center.x = 1920 - size.x/2;
		else if (center.x - size.x/2 < 0)
			center.x = size.x/2;
		
		handler.textBoxes.Push(self);
	}
	
	override void Execute(double fracTic)
	{
		center.y -= size.y / 2;
		
		size.y = 0;
		int fHeight = bigfont.GetHeight();
		
		int scaledFH = fHeight * textScale;
		let lines = bigfont.BreakLines(text, size.x/textScale);
		for (int i = 0; i < lines.Count(); ++i)
			size.y += scaledFH;
		
		center.y += size.y / 2;
		
		if (center.y + size.y/2 > 1080)
			center.y = 1080 - size.y/2;
		else if (center.y - size.y/2 < 0)
			center.y = size.y/2;
		
		super.Execute(fracTic);
		
		PreDraw();
		
		int hOfs;
		for (uint i = 0; i < lines.Count(); ++i)
		{
			let line = lines.StringAt(i);
			DrawText(bigfont, Font.CR_BLACK, (scaledCenter.x-scaledSize.x/2, scaledCenter.y-scaledSize.y/2), line, (0,hOfs), textScale);
			hOfs += fHeight;
		}
		
		PostDraw();
	}
	
	virtual void PreDraw() {}
	
	virtual void PostDraw()
	{
		Screen.DrawFrame(scaledCenter.x-scaledSize.x/2, scaledCenter.y-scaledSize.y/2, scaledSize.x, scaledSize.y);
	}
	
	override void OnDestroy()
	{
		handler.textBoxes.Delete(handler.textBoxes.Find(self));
		
		super.OnDestroy();
	}
}

class ItemCanvas : MenuElement
{
	private int curItem;
	int maxItemsRow;
	Vector2 offset;
	Vector2 defaultPos;
	Vector2 pos;
	
	uint Find(Inventory item)
	{
		uint i;
		for (; i < children.Size(); ++i)
		{
			let child = ItemBox(children[i]);
			if (!child)
				continue;
			
			if (child.item == item)
				return i;
		}
		
		return i;
	}
	
	override void Initialize()
	{
		super.Initialize();
		
		bNoCollision = true;
		offset = (150,150);
		defaultPos = pos = (center.x - size.x/2 + 100, center.y - size.y/2 + 100);
		maxItemsRow = 5;
		background = TexMan.CheckForTexture("AUTOPAGE", TexMan.Type_Any);
		backgroundAlpha = 0.6;
	}
	
	override void Tick()
	{
		// Remove items no longer present
		for (uint i = 0; i < children.Size(); ++i)
		{
			let child = ItemBox(children[i]);
			if (!child || handler.items.Find(child.item) != handler.items.Size())
				continue;
			
			for (uint j = children.Size() - 1; j > i; --j)
			{
				let ib = ItemBox(children[j]);
				if (!ib)
					continue;
					
				for (; j > i; --j)
				{
					let previb = ItemBox(children[j-1]);
					if (previb)
					{
						ib.center = previb.center;
						break;
					}
				}
			}
			
			child.Destroy();
			children.Delete(i--);
			if (--curItem >= 0)
				pos.x -= offset.x;
			else
			{
				curItem = maxItemsRow - 1;
				pos.y -= offset.y;
				pos.x = defaultPos.x + offset.x*curItem;
			}
		}
		
		// Add new items
		for (uint i = 0; i < handler.items.Size(); ++i)
		{
			if (Find(handler.items[i]) != children.Size())
				continue;
			
			let ib = ItemBox(MenuElement.Create("ItemBox", handler, pos, (100,100), self));
			if (ib)
			{
				ib.item = handler.items[i];
				if (++curItem < maxItemsRow)
					pos.x += offset.x;
				else
				{
					curItem = 0;
					pos.x = defaultPos.x;
					pos.y += offset.y;
				}
			}
		}
		
		super.Tick();
	}
	
	override void Execute(double fracTic)
	{
		super.Execute(fracTic);
		
		if (handler.player)
		{
			String text = String.Format("Weight: %.1f / %.1f", handler.player.currentCapacity/10., handler.player.carryCapacity/10.);
			DrawText(bigfont, Font.CR_BLACK, (scaledCenter.x-scaledSize.x/2, scaledCenter.y-scaledSize.y/2), text, (0,0), 1.5);
		}
		
		Screen.DrawFrame(scaledCenter.x-scaledSize.x/2, scaledCenter.y-scaledSize.y/2, scaledSize.x, scaledSize.y);
	}
}

class ItemBox : MenuElement
{
	Inventory item;
	TextBox text;
	
	bool bHighlighted;
	
	int leftClickTimer;
	int rightClickTimer;
	
	void Swap(ItemBox other)
	{
		if (!other || self == other)
			return;
		
		uint index = parent.children.Find(self);
		uint otherIndex = parent.children.Find(other);
		parent.children[otherIndex] = self;
		parent.children[index] = other;
		
		Vector2 temp = other.center;
		other.center = center;
		center = temp;
		
		if (!item || !other.item)
			return;
		
		string command = String.Format("swapitem:%s:%s", item.GetClassName(), other.item.GetClassName());
		EventHandler.SendNetworkEvent(command);
	}
	
	override void Tick()
	{
		super.Tick();
		
		bHighlighted = false;
		if (item == players[consoleplayer].mo.InvSel)
			bHighlighted = true;
	}
	
	override void Clear()
	{
		super.Clear();
		
		leftClickTimer = 0;
		rightClickTimer = 0;
	}
	
	override void OnHeld()
	{
		scaledCenter = handler.mouse;
		Screen.DrawFrame(scaledCenter.x-scaledSize.x/2, scaledCenter.y-scaledSize.y/2, scaledSize.x, scaledSize.y);
	}
	
	virtual void OnHighlighted()
	{
		Screen.DrawFrame(scaledCenter.x-scaledSize.x/2, scaledCenter.y-scaledSize.y/2, scaledSize.x, scaledSize.y);
	}
	
	override void OnHover()
	{
		if (!bSelected && !bHighlighted)
			Screen.DrawFrame(scaledCenter.x-scaledSize.x/2, scaledCenter.y-scaledSize.y/2, scaledSize.x, scaledSize.y);
		
		if (item)
		{
			string title = item.GetTag();
			int titleLength = bigfont.StringWidth(title);
			int fHeight = bigfont.GetHeight();
			
			DrawText(bigfont, Font.CR_BLACK, scaledCenter-(0,scaledSize.y/2), title, (-titleLength / 2, -fHeight));
			
			if (!text)
				text = TextBox(MenuElement.Create("TextBox", handler, (center.x, center.y+size.y/2), (300,0)));
			
			let rpgi = RPGItem(item);
			if (rpgi && text)
				text.text = String.Format("Weight: %.1f\nTotal: %.1f\n\n%s", rpgi.weight/10., rpgi.weight*rpgi.amount/10., rpgi.description);
		}
		
		if (!bLeftClicked && !bRightClicked)
		{
			if (handler.buttonAction == BI_USE)
			{
				string use = "use:"..item.GetClassName();
				EventHandler.SendNetworkEvent(use);
			}
		}
	}
	
	override void Execute(double fracTic)
	{
		super.Execute(fracTic);
		
		if (!bHeld && !bSelected && bHighlighted)
			OnHighlighted();
		
		if (item)
		{
			DrawTexture(item.icon, scaledCenter, (2,2));
		
			if (!bHeld)
			{
				int fHeight = bigfont.GetHeight();
				string amount = String.Format("%d", item.amount);
				int amtLength = bigfont.StringWidth(amount);
				
				DrawText(bigfont, Font.CR_BLACK, scaledCenter+(scaledSize.x/2, scaledSize.y/2), amount, (-amtLength, -fHeight));
			}
		}
		
		if (text && !bHovering)
			text.Destroy();
		
		if (leftClickTimer > 0)
			leftClickTimer -= deltatime;
	}
	
	override void OnLeftClick()
	{
		if (leftClickTimer > 0)
		{
			string use = "use:"..item.GetClassName();
			EventHandler.SendNetworkEvent(use);
			leftClickTimer = 0;
		}
	}
	
	override void OnLeftRelease()
	{
		if (item)
		{
			if (bHeld)
			{
				scaledCenter = handler.mouse;
				handler.UpdateCollision(self);
				let t = ItemBox(touching);
				if (t && t.parent == parent)
					Swap(t);
				
				bHeld = false;
			}
			else if (bLeftClicked)
			{
				players[consoleplayer].mo.InvSel = item;
				if (leftClickTimer <= 0)
					leftClickTimer = 250;
			}
		}
		
		holdTimer = 0;
	}
	
	override void OnLeftHold()
	{
		if (bLeftClicked)
		{
			if (holdTimer < 250)
				holdTimer += deltatime;
			else
				bHeld = true;
		}
	}
	
	override void OnRightHold()
	{
		if (bRightClicked)
		{
			if (rightClickTimer < 250)
				rightClickTimer += deltatime;
		}
	}
	
	override void OnRightRelease()
	{
		if (item)
		{
			string drop = "drop:"..item.GetClassName();
			
			if (rightClickTimer >= 250)
			{
				for (int i = 0; i < item.amount; ++i)
					EventHandler.SendNetworkEvent(drop);
			}
			else				
				EventHandler.SendNetworkEvent(drop);
		}
		
		rightClickTimer = 0;
	}
	
	override void OnDestroy()
	{
		if (text)
			text.Destroy();
		
		super.OnDestroy();
	}
}

class KeyItemCanvas : MenuElement
{
	private int curItem;
	int maxItemsRow;
	Vector2 offset;
	Vector2 defaultPos;
	Vector2 pos;
	
	uint Find(Inventory item)
	{
		uint i;
		for (; i < children.Size(); ++i)
		{
			let child = KeyItemBox(children[i]);
			if (!child)
				continue;
			
			if (child.item == item)
				return i;
		}
		
		return i;
	}
	
	override void Initialize()
	{
		super.Initialize();
		
		bNoCollision = true;
		offset = (150,150);
		defaultPos = pos = (center.x - size.x/2 + 100, center.y - size.y/2 + 100);
		maxItemsRow = 7;
		background = TexMan.CheckForTexture("AUTOPAGE", TexMan.Type_Any);
		backgroundAlpha = 0.6;
	}
	
	override void Tick()
	{
		// Remove items no longer present
		for (uint i = 0; i < children.Size(); ++i)
		{
			let child = KeyItemBox(children[i]);
			if (!child || handler.keyItems.Find(child.item) != handler.keyItems.Size())
				continue;
			
			for (uint j = children.Size() - 1; j > i; --j)
			{
				let ib = KeyItemBox(children[j]);
				if (!ib)
					continue;
					
				for (; j > i; --j)
				{
					let previb = KeyItemBox(children[j-1]);
					if (previb)
					{
						ib.center = previb.center;
						break;
					}
				}
			}
			
			child.Destroy();
			children.Delete(i--);
			if (--curItem >= 0)
				pos.x -= offset.x;
			else
			{
				curItem = maxItemsRow - 1;
				pos.y -= offset.y;
				pos.x = defaultPos.x + offset.x*curItem;
			}
		}
		
		// Add new items
		for (uint i = 0; i < handler.keyItems.Size(); ++i)
		{
			if (Find(handler.keyItems[i]) != children.Size())
				continue;
			
			let ib = KeyItemBox(MenuElement.Create("KeyItemBox", handler, pos, (100,100), self));
			if (ib)
			{
				ib.item = handler.keyItems[i];
				if (++curItem < maxItemsRow)
					pos.x += offset.x;
				else
				{
					curItem = 0;
					pos.x = defaultPos.x;
					pos.y += offset.y;
				}
			}
		}
		
		super.Tick();
	}
	
	override void Execute(double ticFrac)
	{
		super.Execute(ticFrac);
		
		Screen.DrawFrame(scaledCenter.x-scaledSize.x/2, scaledCenter.y-scaledSize.y/2, scaledSize.x, scaledSize.y);
	}
}

class KeyItemBox : MenuElement
{
	Inventory item;
	
	void Swap(KeyItemBox other)
	{
		if (!other || self == other)
			return;
		
		uint index = parent.children.Find(self);
		uint otherIndex = parent.children.Find(other);
		parent.children[otherIndex] = self;
		parent.children[index] = other;
		
		Vector2 temp = other.center;
		other.center = center;
		center = temp;
		
		if (!item || !other.item)
			return;
		
		string command = String.Format("swapitem:%s:%s", item.GetClassName(), other.item.GetClassName());
		EventHandler.SendNetworkEvent(command);
	}
	
	override void OnHeld()
	{
		scaledCenter = handler.mouse;
		Screen.DrawFrame(scaledCenter.x-scaledSize.x/2, scaledCenter.y-scaledSize.y/2, scaledSize.x, scaledSize.y);
	}
	
	override void OnHover()
	{
		Screen.DrawFrame(scaledCenter.x-scaledSize.x/2, scaledCenter.y-scaledSize.y/2, scaledSize.x, scaledSize.y);
		
		if (item)
		{
			string title = item.GetTag();
			int titleLength = bigfont.StringWidth(title);
			int fHeight = bigfont.GetHeight();
			
			DrawText(bigfont, Font.CR_BLACK, scaledCenter-(0,scaledSize.y/2), title, (-titleLength / 2, -fHeight));
		}
	}
	
	override void Execute(double fracTic)
	{
		super.Execute(fracTic);
		
		if (item)
		{
			DrawTexture(item.icon, scaledCenter, (2,2));
		
			if (!bHeld)
			{
				int fHeight = bigfont.GetHeight();
				string amount = String.Format("%d", item.amount);
				int amtLength = bigfont.StringWidth(amount);
				
				DrawText(bigfont, Font.CR_BLACK, scaledCenter+(scaledSize.x/2, scaledSize.y/2), amount, (-amtLength, -fHeight));
			}
		}
	}
	
	override void OnLeftRelease()
	{
		if (item && bHeld)
		{
			scaledCenter = handler.mouse;
			handler.UpdateCollision(self);
			let t = KeyItemBox(touching);
			if (t && t.parent == parent)
				Swap(t);
				
			bHeld = false;
		}
		
		holdTimer = 0;
	}
	
	override void OnLeftHold()
	{
		if (bLeftClicked)
		{
			if (holdTimer < 250)
				holdTimer += deltatime;
			else
				bHeld = true;
		}
	}
}

class ArmorBox : MenuElement
{
	enum EArmorTypes
	{
		AT_HEAD = 1,
		AT_AMUL,
		AT_CHEST,
		AT_BRACE,
		AT_SHIELD
	}
	
	TextBox text;
	Inventory armor;
	int type;
	
	override void Initialize()
	{
		super.Initialize();
		
		background = TexMan.CheckForTexture("ARTIBOX", TexMan.Type_Any);
		backgroundAlpha = 0.6;
		bNoCollision = true;
	}
	
	override void Tick()
	{
		if (!armor)
		{
			if (text)
				text.Destroy();
			
			switch (type)
			{
				case AT_HEAD:
					armor = players[consoleplayer].mo.FindInventory("HelmetPiece");
					break;
					
				case AT_AMUL:
					armor = players[consoleplayer].mo.FindInventory("AmuletPiece");
					break;
					
				case AT_CHEST:
					armor = players[consoleplayer].mo.FindInventory("ChestPiece");
					break;
					
				case AT_BRACE:
					armor = players[consoleplayer].mo.FindInventory("BracerPiece");
					break;
					
				case AT_SHIELD:
					armor = players[consoleplayer].mo.FindInventory("ShieldPiece");
					break;
			}
		}
		else if (armor.owner != players[consoleplayer].mo)
			armor = null;
		
		super.Tick();
	}
	
	override void Execute(double fracTic)
	{
		super.Execute(fracTic);
		
		if (armor)
		{
			double ratio = (1 - armor.health*1. / armor.default.health) * 0.8;
			int alpha = int(0xFF * ratio) << 24;
			int col = alpha | 0x00FF0000;
			
			DrawTexture(armor.icon, scaledCenter, (2.25,2.25), color: col);
		}
		
		if (text && !bHovering)
			text.Destroy();
	}
	
	override void OnHover()
	{
		if (!armor)
			return;
		
		if (!text)
			text = TextBox(MenuElement.Create("TextBox", handler, (center.x, center.y+size.y/2), (500,0)));
		
		if (text)
		{
			text.text = String.Format("Durability: %d / %d\n\n", armor.health, armor.default.health);
			switch (type)
			{
				case AT_HEAD:
					text.text.AppendFormat("Reduces critical damage by 20%");
					break;
					
				case AT_AMUL:
					text.text.AppendFormat("Extra resistance to elemental damage but reduced effectiveness against physical damage. Can absorb poison");
					break;
					
				case AT_CHEST:
					text.text.AppendFormat("Sturdy armor that can take many hits. Extra resistance against cleaving but weak to lightning and blunt hits");
					break;
					
				case AT_BRACE:
					text.text.AppendFormat("Extra effectiveness against physical damage");
					break;
					
				case AT_SHIELD:
					text.text.AppendFormat("Can block piercing hits");
					break;
			}
		}
	}
	
	override void OnDestroy()
	{
		if (text)
			text.Destroy();
		
		super.OnDestroy();
	}
}

class StatCanvas : MenuElement
{
	MenuElement button;
	double hOffset;
	Vector2 pos;
	
	override void Initialize()
	{
		super.Initialize();
		
		hOffset = 125;
		pos = (center.x, center.y - size.y/2 + hOffset/2);
		bNoCollision = true;
		background = TexMan.CheckForTexture("AUTOPAGE", TexMan.Type_Any);
		backgroundAlpha = 0.6;
	}
	
	uint Find(Stat st)
	{
		uint i;
		for (; i < children.Size(); ++i)
		{
			let child = StatBox(children[i]);
			if (!child)
				continue;
			
			if (child.st == st)
				return i;
		}
		
		return i;
	}
	
	override void Tick()
	{
		// Remove stats no longer present
		for (uint i = 0; i < children.Size(); ++i)
		{
			let child = StatBox(children[i]);
			if (!child || handler.stats.Find(child.st) != handler.stats.Size())
				continue;
			
			for (uint j = children.Size() - 1; j > i; --j)
			{
				let sb = StatBox(children[j]);
				if (!sb)
					continue;
					
				for (; j > i; --j)
				{
					let prevsb = StatBox(children[j-1]);
					if (prevsb)
					{
						sb.Shift(sb.center - prevsb.center);
						break;
					}
				}
			}
			
			child.Destroy();
			children.Delete(i--);
			if (children.Size())
				pos.y -= hOffset;
		}
		
		// Add new stats
		for (uint i = 0; i < handler.stats.Size(); ++i)
		{
			if (Find(handler.stats[i]) != children.Size())
				continue;
			
			let sb = StatBox(MenuElement.Create("StatBox", handler, pos, (size.x,hOffset), self));
			if (sb)
			{
				sb.st = handler.stats[i];
				sb.st.currentLevel = sb.st.level;
				sb.st.currentCost = 0;
				if (sb.description)
					sb.description.text = sb.st.description;
				
				pos.y += hOffset;
			}
		}
		
		super.Tick();
	}
	
	override void Execute(double fracTic)
	{
		super.Execute(fracTic);
		
		Screen.DrawFrame(scaledCenter.x-scaledSize.x/2, scaledCenter.y-scaledSize.y/2, scaledSize.x, scaledSize.y);
		
		if (handler.totalCost > 0)
		{
			int fHeight = bigfont.GetHeight();
			String text = String.Format("XP Required: %d", handler.totalCost);
			int length = bigfont.StringWidth(text);
			DrawText(bigfont, Font.CR_UNTRANSLATED, (scaledCenter.x, scaledCenter.y-scaledSize.y/2), text, (-length/2, -fHeight), 2);
		}
		
		if (handler.player &&
			(handler.player.currentPoints != handler.player.points || handler.totalCost > 0))
		{
			if (!button)
				button = MenuElement.Create("ConfirmButton", handler, (center.x, center.y+size.y/2+100), (200,100), self);
		}
		else if (button)
			button.Destroy();
	}
	
	override void OnDestroy()
	{
		if (button)
			button.Destroy();
		
		super.OnDestroy();
	}
}

class StatBox : MenuElement
{
	Stat st;
	StatTextBox description;
	StatTextBox bonus;
	
	override void Initialize()
	{
		super.Initialize();
		
		bNoCollision = true;
		MenuElement.Create("StatIncrementer", handler, (center.x-size.x/2 + 50, center.y), (100,100), self);
		MenuElement.Create("LevelDisplay", handler, (center.x-size.x/2 + 150, center.y), (100,100), self);
		MenuElement.Create("StatDecrementer", handler, (center.x-size.x/2 + 250, center.y), (100,100), self);
		description = StatTextBox(MenuElement.Create("StatTextBox", handler, (center.x-size.x/2 + 650, center.y), (600, 100)));
		bonus = StatTextBox(MenuElement.Create("StatTextBox", handler, (center.x-size.x/2 + 1100, center.y), (300, 100)));
	}
	
	override void Execute(double fracTic)
	{
		super.Execute(fracTic);
		
		if (st && bonus)
		{
			String text = "";
			
			if (st.currentLevel > 1)
			{
				for (uint i = 0; i < st.bonusValue.Size(); ++i)
				{
					int val = st.bonusValue[i] * (st.currentLevel - 1);
					if (val > 0)
						text.AppendFormat("+");
					
					text.AppendFormat("%d%s", val, st.bonusText[i]);
				}
			}
			
			bonus.text = text;
		}
	}
	
	override void OnDestroy()
	{
		if (description)
			description.Destroy();
		
		if (bonus)
			bonus.Destroy();
		
		super.OnDestroy();
	}
}

class StatIncrementer : MenuElement
{
	override void Initialize()
	{
		super.Initialize();
		
		bNoCollision = true;
	}
	
	override void OnHover()
	{
		Screen.DrawFrame(scaledCenter.x-scaledSize.x/2, scaledCenter.y-scaledSize.y/2, scaledSize.x, scaledSize.y);
	}
	
	override void Execute(double fracTic)
	{
		super.Execute(fracTic);
		
		let st = StatBox(parent).st;
		if (!st)
			return;
		
		DrawText(bigfont, Font.CR_UNTRANSLATED, (scaledCenter.x, scaledCenter.y), "+", scale: 3);
	}
	
	override void OnLeftRelease()
	{
		let st = StatBox(parent).st;
		if (!st || !handler.player)
			return;
		
		if (st.currentLevel < st.maxLevel && handler.player.currentPoints > 0)
		{
			++st.currentLevel;
			--handler.player.currentPoints;
			if (st.currentLevel <= st.level)
				st.currentCost -= st.cost;
		}
	}
}

class StatDecrementer : MenuElement
{
	override void Initialize()
	{
		super.Initialize();
		
		bNoCollision = true;
	}
	
	override void OnHover()
	{
		Screen.DrawFrame(scaledCenter.x-scaledSize.x/2, scaledCenter.y-scaledSize.y/2, scaledSize.x, scaledSize.y);
	}
	
	override void Execute(double fracTic)
	{
		super.Execute(fracTic);
		
		let st = StatBox(parent).st;
		if (!st)
			return;
		
		DrawText(bigfont, Font.CR_UNTRANSLATED, (scaledCenter.x, scaledCenter.y), "-", scale: 3);
	}
	
	override void OnLeftRelease()
	{
		let st = StatBox(parent).st;
		if (!st || !handler.player)
			return;
		
		if (st.currentLevel > st.minLevel)
		{
			--st.currentLevel;
			++handler.player.currentPoints;
			if (st.currentLevel < st.level)
				st.currentCost += st.cost;
		}
	}
}

class LevelDisplay : MenuElement
{
	ui int oldLevel;
	
	override void Initialize()
	{
		super.Initialize();
		
		bNoCollision = true;
	}
	
	override void Tick()
	{
		let st = StatBox(parent).st;
		if (st)
		{
			if (oldLevel != st.level)
				st.currentLevel = st.level;
			
			oldLevel = st.level;
		}
		
		super.Tick();
	}
	
	override void Execute(double fracTic)
	{
		super.Execute(fracTic);
		
		let st = StatBox(parent).st;
		if (!st)
			return;
		
		int col = Font.CR_BLACK;
		if (st.currentLevel < st.level)
			col = Font.CR_RED;
		else if (st.currentLevel > st.level)
			col = Font.CR_GREEN;
		
		DrawText(bigfont, col, (scaledCenter.x, scaledCenter.y), String.Format("%d", st.currentLevel), scale: 3);
	}
}

class StatTextBox : TextBox
{
	override void Initialize()
	{
		super.Initialize();
		
		background.SetInvalid();
		textScale = 1.5;
	}
	
	override void PostDraw() {}
}

class ConfirmButton : MenuElement
{
	override void OnHover()
	{
		Screen.DrawFrame(scaledCenter.x-scaledSize.x/2, scaledCenter.y-scaledSize.y/2, scaledSize.x, scaledSize.y);
	}
	
	override void Execute(double fracTic)
	{
		super.Execute(fracTic);
		
		int fHeight = bigfont.GetHeight();
		String con = "Confirm";
		int length = bigfont.StringWidth(con);
		
		DrawText(bigfont, Font.CR_BLACK, scaledCenter, con, (-length/2, -fHeight/2), 2);
	}
	
	override void OnLeftRelease()
	{
		handler.LevelPlayer();
	}
}