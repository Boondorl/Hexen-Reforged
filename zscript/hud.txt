class ReforgedStatusBar : BaseStatusBar
{
	DynamicValueInterpolator mHealthInterpolator;
	DynamicValueInterpolator mBlueManaInterpolator;
	DynamicValueInterpolator mGreenManaInterpolator;
	DynamicValueInterpolator mRedManaInterpolator;
	DynamicValueInterpolator mXPInterpolator;
	DynamicValueInterpolator mCapacityInterpolator;
	HUDFont mHUDFont;
	HUDFont mIndexFont;
	HUDFont mBigFont;
	InventoryBarState diparms;
	InventoryBarState diparms_sbar;
	

	override void Init()
	{
		Super.Init();
		SetSize(0, 320, 200);

		// Create the font used for the fullscreen HUD
		Font fnt = "HUDFONT_RAVEN";
		mHUDFont = HUDFont.Create(fnt, fnt.GetCharWidth("0") + 1, Mono_CellLeft, 1, 1);
		fnt = "INDEXFONT_RAVEN";
		mIndexFont = HUDFont.Create(fnt, fnt.GetCharWidth("0"), Mono_CellLeft);
		fnt = "BIGFONT";
		mBigFont = HUDFont.Create(fnt, fnt.GetCharWidth("0"), Mono_CellLeft, 2, 2);
		diparms = InventoryBarState.Create(mIndexFont);
		diparms_sbar = InventoryBarState.CreateNoBox(mIndexFont, boxsize:(31, 31), arrowoffs:(0,-10));
		mHealthInterpolator = DynamicValueInterpolator.Create(0, 0.25, 1, 8);
		mBlueManaInterpolator = DynamicValueInterpolator.Create(0, 0.25, 1, 8);
		mGreenManaInterpolator = DynamicValueInterpolator.Create(0, 0.25, 1, 8);
		mRedManaInterpolator = DynamicValueInterpolator.Create(0, 0.25, 1, 8);
		mXPInterpolator = DynamicValueInterpolator.Create(0, 0.25, 1, 200);
		mCapacityInterpolator = DynamicValueInterpolator.Create(0, 0.25, 1, 8);
	}
	
	override void NewGame ()
	{
		Super.NewGame();
		mHealthInterpolator.Reset(0);
		mBlueManaInterpolator.Reset(0);
		mGreenManaInterpolator.Reset(0);
		mRedManaInterpolator.Reset(0);
		mXPInterpolator.Reset(0);
		mCapacityInterpolator.Reset(0);
	}

	override void Tick()
	{
		Super.Tick();
		mHealthInterpolator.Update(CPlayer.health);
		let bm = CPlayer.mo.FindInventory("BlueMana");
		if (bm)
			mBlueManaInterpolator.Update(bm.amount);
		
		let gm = CPlayer.mo.FindInventory("GreenMana");
		if (gm)
			mGreenManaInterpolator.Update(gm.amount);
		
		let rm = CPlayer.mo.FindInventory("RedMana");
		if (rm)
			mRedManaInterpolator.Update(rm.amount);
		
		let rpg = RPGPlayer(CPlayer.mo);
		if (rpg)
		{
			mXPInterpolator.Update(rpg.currentXP);
			mCapacityInterpolator.Update(rpg.currentCapacity);
		}
	}

	override void Draw (int state, double TicFrac)
	{
		Super.Draw (state, TicFrac);
		
		if (state == HUD_Fullscreen || state == HUD_StatusBar)
		{
			BeginHUD();
			DrawFullScreenStuff ();
		}
	}

	protected void DrawFullScreenStuff()
	{
		// Chain and gem
		String Gem, Chain;
		if (CPlayer.mo is "ReforgedCleric")
		{
			Gem = "LIFEGMC2";
			Chain = "CHAIN2";
		}
		else if (CPlayer.mo is "ReforgedMage")
		{
			Gem = "LIFEGMM2";
			Chain = "CHAIN3";
		}
		else
		{
			Gem = "LIFEGMF2";
			Chain = "CHAIN";
		}
		
		// TODO: Keep centered for multi-monitor
		
		// Get virtual screen width
		Vector2 HUDScale = GetHUDScale();
		int vWidth = Screen.GetWidth() / HUDScale.x;
		int vHeight = Screen.GetHeight() / HUDScale.y;
		
		TextureID orb = TexMan.CheckForTexture("ORB", TexMan.TYPE_MiscPatch);
		Vector2 orbSize = TexMan.GetScaledSize(orb);
		orbSize.y *= 1.2;
		orbSize *= 0.7;
		
		// Get Gargoyle information first to find gem offset
		TextureID gargl = TexMan.CheckForTexture("GARGL", TexMan.TYPE_MiscPatch);
		TextureID gargr = TexMan.CheckForTexture("GARGR", TexMan.TYPE_MiscPatch);
		Vector2 garglSize = TexMan.GetScaledSize(gargl);
		Vector2 gargrSize = TexMan.GetScaledSize(gargr);
		
		garglSize.y *= 1.2;
		garglSize *= 0.7;
		gargrSize.y *= 1.2;
		gargrSize *= 0.7;

		// Chain size and gem information
		int curXP =  mXPInterpolator.GetValue();
		TextureID chaintex = TexMan.CheckForTexture(chain, TexMan.TYPE_MiscPatch);
		TextureID gemtex = TexMan.CheckForTexture(gem, TexMan.TYPE_MiscPatch);
		Vector2 chainsize = TexMan.GetScaledSize(chaintex);
		Vector2 gemsize = TexMan.GetScaledSize(gemtex);
		
		chainsize.y *= 1.2;
		chainsize *= 0.7;
		gemsize.y *= 1.2;
		gemsize *= 0.7;
		
		int nextLevelXP = 0;
		if (CPlayer.mo is 'RPGPlayer')
			nextLevelXP = RPGPlayer(CPlayer.mo).nextLevelXP;

		// Get gem offset
		curXP = clamp(curXP, 0, nextLevelXP);
		int offset = ((vWidth - gargrSize.x - gemsize.x) - garglSize.x) * (curXP*1. / max(1, nextLevelXP));
	
		// Draw the chain and gem
		for (int i = 0; i < vWidth; i += chainsize.x)
			DrawImage(chain, (i + (offset % 15), -chainsize.y), DI_ITEM_OFFSETS, scale: (0.7, 0.84));
		
		DrawImage(gem, (garglSize.x + offset, -gemsize.y), DI_ITEM_OFFSETS, scale: (0.7, 0.84));
		
		// Health
		int maxHealth = CPlayer.mo.maxHealth ? CPlayer.mo.maxHealth : CPlayer.mo.default.health;
		int health = mHealthInterpolator.GetValue();
		
		double healthRatio = health*1. / maxHealth;
		if (healthRatio > 1)
			healthRatio = 1;
		
		int cx, cy, cw, ch;
		[cx, cy, cw, ch] = Screen.GetClipRect();
		
		int clipHeight = orbSize.y*healthRatio;
		SetClipRect(0, vHeight-orbSize.y+(orbSize.y-clipHeight), orbSize.x, clipHeight);
		
		DrawImage("HEALTH", (0, -orbSize.y), DI_ITEM_OFFSETS, scale: (0.7, 0.84));
		
		Screen.SetClipRect(cx, cy, cw, ch);
		
		int fHeight = mBigFont.mFont.GetHeight();
		String healthNum = "Life";
		DrawString(mBigFont, healthNum, (orbSize.x/6, -orbSize.y - fHeight*0.6), scale: (0.3, 0.3));
		DrawString(mHUDFont, FormatNumber(mHealthInterpolator.GetValue()), (orbSize.x*5/6., -orbSize.y - fHeight*0.6), DI_TEXT_ALIGN_RIGHT, scale: (0.5, 0.5));
		
		//armor
		int ac = 0;
		let am = ArmorPieceManager(CPlayer.mo.FindInventory("ArmorPieceManager"));
		if (am)
			ac = am.GetCurrentAC();
		
		String acNum = "AC";
		DrawString(mBigFont, acNum, (orbSize.x/6, -orbSize.y - fHeight*0.3), scale: (0.3, 0.3));
		DrawString(mHUDFont, FormatNumber(ac), (orbSize.x*5/6., -orbSize.y - fHeight*0.3), DI_TEXT_ALIGN_RIGHT, scale: (0.5, 0.5));
		
		// Mana
		let red = CPlayer.mo.FindInventory("RedMana");
		if (red)
		{
			double manaRatio = mRedManaInterpolator.GetValue()*1. / max(1, red.maxAmount);
			if (manaRatio > 1)
				manaRatio = 1;
			
			int cx, cy, cw, ch;
			[cx, cy, cw, ch] = Screen.GetClipRect();
			
			int clipHeight = orbSize.y*manaRatio;
			SetClipRect(vWidth-orbSize.x, vHeight-orbSize.y+(orbSize.y-clipHeight), orbSize.x, clipHeight);
			
			DrawImage("REDMANA", (-orbSize.x, -orbSize.y), DI_ITEM_OFFSETS, scale: (0.7, 0.84));
			
			Screen.SetClipRect(cx, cy, cw, ch);
		}
		
		if (CPlayer.ReadyWeapon)
		{
			let ammo = CPlayer.ReadyWeapon.Ammo1;
			if (ammo is 'BlueMana')
			{
				double manaRatio = mBlueManaInterpolator.GetValue()*1. / max(1, ammo.maxAmount);
				if (manaRatio > 1)
					manaRatio = 1;
				
				int cx, cy, cw, ch;
				[cx, cy, cw, ch] = Screen.GetClipRect();
				
				int clipHeight = orbSize.y*manaRatio;
				SetClipRect(vWidth-orbSize.x, vHeight-orbSize.y+(orbSize.y-clipHeight), orbSize.x, clipHeight);
				
				DrawImage("BLUEMANA", (-orbSize.x, -orbSize.y), DI_ITEM_OFFSETS, scale: (0.7, 0.84));
				
				Screen.SetClipRect(cx, cy, cw, ch);
			}
			else if (ammo is 'GreenMana')
			{
				double manaRatio = mGreenManaInterpolator.GetValue()*1. / max(1, ammo.maxAmount);
				if (manaRatio > 1)
					manaRatio = 1;
				
				int cx, cy, cw, ch;
				[cx, cy, cw, ch] = Screen.GetClipRect();
				
				int clipHeight = orbSize.y*manaRatio;
				SetClipRect(vWidth-orbSize.x, vHeight-orbSize.y+(orbSize.y-clipHeight), orbSize.x, clipHeight);
				
				DrawImage("GREEMANA", (-orbSize.x, -orbSize.y), DI_ITEM_OFFSETS, scale: (0.7, 0.84));
				
				Screen.SetClipRect(cx, cy, cw, ch);
			}
		}
		
		TextureID plate = TexMan.CheckForTexture("MANABRT1", TexMan.TYPE_MiscPatch);
		Vector2 plateSize = TexMan.GetScaledSize(plate);
		plateSize.y *= 1.2;
		plateSize *= 0.5;
		
		Ammo ammo1, ammo2, ammo3;
		[ammo1, ammo2, ammo3] = GetMana();
		let weap = CPlayer.ReadyWeapon;
		
		if (weap && weap.Ammo1 is "BlueMana")
			DrawImage("MANABRT1", (-orbSize.x*5/6., -orbsize.y - plateSize.y*3), DI_ITEM_OFFSETS, scale: (0.5,0.6));
		else
			DrawImage("MANADIM1", (-orbSize.x*5/6., -orbsize.y - plateSize.y*3), DI_ITEM_OFFSETS, scale: (0.5,0.6));
		
		if (weap && weap.Ammo1 is "GreenMana")
			DrawImage("MANABRT2", (-orbSize.x*5/6., -orbsize.y - plateSize.y*2), DI_ITEM_OFFSETS, scale: (0.5,0.6));
		else
			DrawImage("MANADIM2", (-orbSize.x*5/6., -orbsize.y - plateSize.y*2), DI_ITEM_OFFSETS, scale: (0.5,0.6));
		
		if (weap && (weap.Ammo1 is "RedMana" || weap.Ammo2 is "RedMana"))
			DrawImage("MANABRT2", (-orbSize.x*5/6., -orbsize.y - plateSize.y), DI_ITEM_OFFSETS, scale: (0.5,0.6));
		else
			DrawImage("MANADIM2", (-orbSize.x*5/6., -orbsize.y - plateSize.y), DI_ITEM_OFFSETS, scale: (0.5,0.6));
		
		DrawString(mHUDFont, FormatNumber(GetAmount("BlueMana")), (-orbSize.x/6, -orbsize.y - plateSize.y*2.9), DI_TEXT_ALIGN_RIGHT, scale: (0.5,0.5));
		DrawString(mHUDFont, FormatNumber(GetAmount("GreenMana")), (-orbSize.x/6, -orbsize.y - plateSize.y*1.9), DI_TEXT_ALIGN_RIGHT, scale: (0.5,0.5));
		DrawString(mHUDFont, FormatNumber(GetAmount("RedMana")), (-orbSize.x/6, -orbsize.y - plateSize.y*0.9), DI_TEXT_ALIGN_RIGHT, scale: (0.5,0.5));
		
		// Orbs
		DrawImage("ORB", (0, -orbSize.y), DI_ITEM_OFFSETS, scale: (0.7, 0.84));
		DrawImage("ORB", (-orbSize.x, -orbSize.y), DI_ITEM_OFFSETS, scale: (0.7, 0.84));
		
		// Gargoyles
		DrawImage("GARGL", (0, -garglSize.y), DI_ITEM_OFFSETS, scale: (0.7, 0.84));
		DrawImage("GARGR", (-gargrSize.x, -gargrSize.y), DI_ITEM_OFFSETS, scale: (0.7, 0.84));
		
		// RPG Player specific coding
		let rpg = RPGPlayer(CPlayer.mo);
		if (rpg)
		{
			// Points
			if (rpg.points > 0 && !RPGMenuHandler.GetMenuState())
			{
				int length = (vWidth - mBigFont.mFont.StringWidth(String.Format("%d points available", rpg.points))*0.75)/2;
				int height = -chainsize.y - mBigFont.mFont.GetHeight()*0.75;
				DrawString(mBigFont, FormatNumber(rpg.points), (length, height), DI_TEXT_ALIGN_RIGHT, scale: (0.75, 0.75));
				DrawString(mBigFont, " points available", (length, height), DI_TEXT_ALIGN_LEFT, scale: (0.75, 0.75));
			}
			
			// Active skills
			int xOfs = -orbSize.x*1.65 + 24;
			DrawImage("ARTIBOX", (xOfs, -chainSize.y), 0, scale: (0.5, 0.6));
			let skill3 = Skill(rpg.FindInventory(rpg.activeSkills[2]));
			if (skill3)
			{
				double alpha = 1;
				if (skill3.bInCast || skill3.bInCoolDown)
					alpha = 0.5;
				
				int key1, key2;
				[key1, key2] = Bindings.GetKeysForCommand("Spell3");
				int useKey = key1 ? key1 : key2;
				if (useKey)
					DrawString(mBigFont, KeyBindings.NameKeys(useKey, 0), (xOfs-7, -chainSize.y-7), scale: (0.3,0.3));
				else
					DrawString(mBigFont, "-", (xOfs-7, -chainSize.y-7), scale: (0.3,0.3));
				
				DrawTexture(skill3.icon, (xOfs, -chainSize.y-4), DI_ITEM_CENTER_BOTTOM, alpha, scale: (0.5, 0.6));
				if (skill3.bInCoolDown)
					DrawString(mHUDFont, FormatNumber((skill3.coolDownTimer+35) / 35), (xOfs+3, -chainSize.y-13), DI_TEXT_ALIGN_RIGHT, scale: (0.7,0.7));
			}
			xOfs -= 15;
			
			DrawImage("ARTIBOX", (xOfs, -chainSize.y), 0, scale: (0.5, 0.6));
			let skill2 = Skill(rpg.FindInventory(rpg.activeSkills[1]));
			if (skill2)
			{
				double alpha = 1;
				if (skill2.bInCast || skill2.bInCoolDown)
					alpha = 0.5;
				
				int key1, key2;
				[key1, key2] = Bindings.GetKeysForCommand("Spell2");
				int useKey = key1 ? key1 : key2;
				if (useKey)
					DrawString(mBigFont, KeyBindings.NameKeys(useKey, 0), (xOfs-7, -chainSize.y-7), scale: (0.3,0.3));
				else
					DrawString(mBigFont, "-", (xOfs-7, -chainSize.y-7), scale: (0.3,0.3));
				
				DrawTexture(skill2.icon, (xOfs, -chainSize.y-4), DI_ITEM_CENTER_BOTTOM, alpha, scale: (0.5, 0.6));
				if (skill2.bInCoolDown)
					DrawString(mHUDFont, FormatNumber((skill2.coolDownTimer+35) / 35), (xOfs+3, -chainSize.y-13), DI_TEXT_ALIGN_RIGHT, scale: (0.7,0.7));
			}
			xOfs -= 15;
			
			DrawImage("ARTIBOX", (xOfs, -chainSize.y), 0, scale: (0.5, 0.6));
			let skill1 = Skill(rpg.FindInventory(rpg.activeSkills[0]));
			if (skill1)
			{
				double alpha = 1;
				if (skill1.bInCast || skill1.bInCoolDown)
					alpha = 0.5;
				
				int key1, key2;
				[key1, key2] = Bindings.GetKeysForCommand("Spell1");
				int useKey = key1 ? key1 : key2;
				if (useKey)
					DrawString(mBigFont, KeyBindings.NameKeys(useKey, 0), (xOfs-7, -chainSize.y-7), scale: (0.3,0.3));
				else
					DrawString(mBigFont, "-", (xOfs-7, -chainSize.y-7), scale: (0.3,0.3));
				
				DrawTexture(skill1.icon, (xOfs, -chainSize.y-4), DI_ITEM_CENTER_BOTTOM, alpha, scale: (0.5, 0.6));
				if (skill1.bInCoolDown)
					DrawString(mHUDFont, FormatNumber((skill1.coolDownTimer+35) / 35), (xOfs+3, -chainSize.y-13), DI_TEXT_ALIGN_RIGHT, scale: (0.7,0.7));
			}
		}

		//frags/keys
		if (deathmatch)
		{
			DrawString(mHUDFont, FormatNumber(CPlayer.FragCount, 3), (70, -16));
		}
		
		// Inventory item and bar
		DrawImage("IBOX", (orbSize.x*1.65, -chainSize.y), 0, scale: (0.7, 0.84));
		if (!isInventoryBarVisible() && !Level.NoInventoryBar && CPlayer.mo.InvSel != null)
		{
			// This code was changed to always fit the item into the box, regardless of alignment or sprite size.
			// Heretic's ARTIBOX is 30x30 pixels. 
			DrawInventoryIcon(CPlayer.mo.InvSel, (orbSize.x*1.65, -chainSize.y-13), DI_ARTIFLASH|DI_ITEM_CENTER, boxsize:(28, 28), scale: (0.7, 0.84));
			DrawString(mIndexFont, FormatNumber(CPlayer.mo.InvSel.Amount, 3), (orbSize.x*1.65+9, -chainSize.y - mIndexFont.mFont.GetHeight()-1), DI_TEXT_ALIGN_RIGHT);
		}
		
		if (isInventoryBarVisible())
		{
			DrawReforgedItems(diparms, (orbSize.x*1.65, -chainSize.y-2), 3, 0, HX_SHADOW);
		}
	}
	
	Ammo, Ammo, Ammo, int, int, int GetMana() const
	{
		Ammo ammo1, ammo2, ammo3;
		ammo1 = Ammo(CPlayer.mo.FindInventory("BlueMana"));
		ammo2 = Ammo(CPlayer.mo.FindInventory("GreenMana"));
		ammo3 = Ammo(CPlayer.mo.FindInventory("RedMana"));
		
		let ammocount1 = ammo1 != NULL ? ammo1.Amount : 0;
		let ammocount2 = ammo2 != NULL ? ammo2.Amount : 0;
		let ammocount3 = ammo3 != NULL ? ammo3.Amount : 0;
		
		return ammo1, ammo2, ammo3, ammocount1, ammocount2, ammocount3;
	}
	
	void DrawReforgedItems(InventoryBarState parms, Vector2 position, int numfields, int flags = 0, double bgalpha = 1.)
	{
		double width = parms.boxsize.X*0.8 * numfields;
		[position, flags] = AdjustPosition(position, flags, width, parms.boxsize.Y);
		
		// Player has no listed inventory items.
		if (!CPlayer.mo.FirstInv())
			return;
		
		CPlayer.mo.InvFirst = CPlayer.mo.InvSel.PrevInv();
		if (!CPlayer.mo.InvFirst)
		{
			for (let probe = CPlayer.mo.FirstInv(); probe != null; probe = probe.NextInv())
				CPlayer.mo.InvFirst = probe;
		}
		
		Vector2 boxsize = parms.boxsize;
		boxsize.x *= 0.8;
		
		Vector2 itempos = position + boxsize / 2 + (0, 4);
		Vector2 textpos = position + boxsize - (3, -1 + parms.amountfont.mFont.GetHeight());
		
		int k;
		for (let item = CPlayer.mo.InvFirst.NextInv(); item != CPlayer.mo.InvFirst; ++k)
		{
			if (!item)
				item = CPlayer.mo.FirstInv();
			else
				item = item.NextInv();
		}

		int i = k > 1 ? 0 : 1;
		Inventory item;
		for(item = CPlayer.mo.InvFirst; i < numfields; item = item.NextInv())
		{
			if (!item)
			{
				item = CPlayer.mo.FirstInv();
				if (item == CPlayer.mo.InvFirst && k <= 1)
					break;
			}
			
			DrawInventoryIcon(item, itempos + (boxsize.X * i, 0), flags | DI_ITEM_CENTER, scale: (0.7, 0.84));
			DrawString(parms.amountfont, FormatNumber(item.Amount, 0, 5), textpos + (boxsize.X * i, 0), flags | DI_TEXT_ALIGN_RIGHT, parms.cr, parms.itemalpha);
			i++;
		}
	}
}