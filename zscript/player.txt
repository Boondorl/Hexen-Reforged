class RPGPlayer : PlayerPawn abstract
{
	Array<class<Stat> > stats;
	Array<class<Skill> > skills;
	Array<class<Skill> > activeSkills;
	
	int carryCapacity;
	int maxLevel;
	int skillSlots;
	int currentLevel;
	double currentXP;
	double nextLevelXP;
	int points;
	double skillCoolDown;
	double attackModifier;
	
	int currentCapacity;
	ui int tempPoints;
	
	bool bMenuOpen;
	bool bInInv;
	bool bInStats;
	
	property CarryCapacity : carryCapacity;
	property MaxLevel : maxLevel;
	property SkillSlots : skillSlots;
	property StartLevel : currentLevel;
	property StartRequiredXP : nextLevelXP;
	property StartPoints : points;
	property StartXP : currentXP;
	property SkillCoolDown : skillCoolDown;
	property AttackModifier : attackModifier;
	
	Default
	{
		Player.MaxHealth 100;
		Health 100;
		Speed 0.85;
		PainChance 256;
		ReactionTime 0;
		RPGPlayer.SkillCoolDown 1;
		RPGPlayer.AttackModifier 1;
		RPGPlayer.CarryCapacity 100;
		RPGPlayer.MaxLevel 11;
		RPGPlayer.SkillSlots 3;
		RPGPlayer.StartLevel 1;
		RPGPlayer.StartRequiredXP 2000;
		
		+NODAMAGETHRUST
		+PLAYERPAWN.NOTHRUSTWHENINVUL
	}
	
	override void Tick()
	{
		super.Tick();
		
		if (!player || !player.mo || player.mo != self)
			return;
			
		let first = FirstInv();
		if (!first || !first.NextInv())
			player.inventorytics = 0;
		
		if (currentLevel < maxLevel && currentXP >= nextLevelXP)
			LevelUp();
		
		currentCapacity = 0;
		for (let probe = FirstInv(); probe != null; probe = probe.NextInv())
		{
			let rpgi = RPGItem(probe);
			if (rpgi)
				currentCapacity += rpgi.amount*rpgi.weight;
		}
	}
	
	override void GiveDefaultInventory()
	{
		if (!player)
			return;

		// Now add the items from the DECORATE definition
		let di = GetDropItems();

		while (di)
		{
			Class<Actor> ti = di.Name;
			if (ti)
			{
				let tinv = (class<Inventory>)(ti);
				if (!tinv)
				{
					Console.Printf(TEXTCOLOR_ORANGE .. "%s is not an inventory item and cannot be given to a player as start item.\n", di.Name);
				}
				else
				{
					let item = FindInventory(tinv);
					if (item)
					{
						item.Amount = clamp(
							item.Amount + (di.Amount ? di.Amount : item.default.Amount), 0, item.MaxAmount);
					}
					else
					{
						item = Inventory(Spawn(ti));
						item.bIgnoreSkill = true;	// no skill multipliers here
						item.Amount = di.Amount;
						let weap = Weapon(item);
						if (weap)
						{
							// To allow better control any weapon is emptied of
							// ammo before being given to the player.
							weap.AmmoGive1 = weap.AmmoGive2 = 0;
						}
						bool res;
						Actor check;
						[res, check] = item.CallTryPickup(self);
						if (!res)
						{
							item.Destroy();
							item = NULL;
						}
						else if (check != self)
						{
							// Player was morphed. This is illegal at game start.
							// This problem is only detectable when it's too late to do something about it...
							ThrowAbortException("Cannot give morph item '%s' when starting a game!", di.Name);
						}
					}
					let weap = Weapon(item);
					if (weap && weap.CheckAmmo(Weapon.EitherFire, false))
					{
						player.ReadyWeapon = player.PendingWeapon = weap;
					}
				}
			}
			di = di.Next;
		}
		
		for (uint i = 0; i < stats.Size(); ++i)
		{
			let st = Stat(FindInventory(stats[i]));
			if (st)
				st.GiveDefault();
		}
	}
	
	void UseSkill(uint index)
	{
		if (index >= skillSlots)
			return;
		
		if (!activeSkills[index])
			Console.Printf("No skill");
		else
		{
			let skill = FindInventory(activeSkills[index]);
			if (skill)
				skill.Use(false);
		}
	}
	
	virtual void LevelUp()
	{
		if (currentXP >= nextLevelXP)
			currentXP -= nextLevelXP;
		
		++currentLevel;
		nextLevelXP += default.nextLevelXP*0.75;
		++points;
			
		switch (currentLevel)
		{
			case 2:
				if (1 < skills.Size())
					GiveInventoryType(skills[1]);
				break;
				
			case 3:
				if (2 < skills.Size())
					GiveInventoryType(skills[2]);
				break;
				
			case 5:
				if (3 < skills.Size())
					GiveInventoryType(skills[3]);
				if (4 < skills.Size())
					GiveInventoryType(skills[4]);
				break;
				
			case 8:
				if (5 < skills.Size())
					GiveInventoryType(skills[5]);
				if (6 < skills.Size())
					GiveInventoryType(skills[6]);
				break;
				
			case 11:
				if (7 < skills.Size())
					GiveInventoryType(skills[7]);
				break;
		}
	}
	
	virtual void InitializeStats()
	{
		SetStat(0, 'Agility');
		SetStat(1, 'Vitality');
		SetStat(2, 'Wisdom');
		SetStat(3, 'Intelligence');
		SetStat(4, 'Strength');
		SetStat(5, 'Dexterity');
	}
	
	virtual void InitializeSkills() {}
	
	protected void SetStat(uint index, class<Stat> stat)
	{
		stats.Insert(index, stat);
		GiveInventoryType(stat);
	}
	
	protected void SetSkill(uint index, class<Skill> skill, bool give = false)
	{
		skills.Insert(index, skill);
		if (give)
			GiveInventoryType(skill);
	}
	
	protected void SetActiveSkill(uint index, class<Skill> skill = null)
	{
		if (index >= skillSlots)
			return;
		
		if (activeSkills[index])
		{
			let curSkill = Skill(FindInventory(activeSkills[index]));
			if (curSkill)
			{
				curSkill.OnUnequip();
				curSkill.bCurToggle = false;
				curSkill.EndSkill();
				curSkill.bActive = false;
			}
		}
		
		activeSkills.Insert(index, skill);
		if (skill)
		{
			let newSkill = Skill(FindInventory(skill));
			if (newSkill)
			{
				newSkill.OnEquip();
				newSkill.bActive = true;
			}
		}
	}
	
	override void PostBeginPlay()
	{
		super.PostBeginPlay();
		
		GiveInventoryType("ArmorPieceManager");
		GiveInventoryType("BuffManager");
		activeSkills.Resize(skillSlots);
		InitializeStats();
		InitializeSkills();
	}
	
	override void CheatGive(String name, int amount)
	{
		int i;
		class<Inventory> type;

		if (!player.mo || player.health <= 0)
			return;

		int giveall = ALL_NO;
		if (name ~== "all")
			giveall = ALL_YES;
		else if (name ~== "everything")
			giveall = ALL_YESYES;

		if (name ~== "health")
		{
			if (amount > 0)
			{
				health += amount;
				player.health = health;
			}
			else
				player.health = health = GetMaxHealth(true);
			
			return;
		}
		else if (name ~== "level")
		{
			for (int i = 0; i < amount; ++i)
			{
				LevelUp();
			}
			
			return;
		}
		else if (name ~== "xp")
		{
			currentXP += amount;
			return;
		}
		else if (name ~== "point")
		{
			points += amount;
			return;
		}
		
		if (giveall)
		{
			for (int i = currentLevel; i < maxLevel; ++i)
			{
				LevelUp();
			}
			
			points = 0;
			currentXP = nextLevelXP;
			
			for (let probe = inv; probe != null; probe = probe.inv)
			{
				let stat = Stat(probe);
				if (stat)
					stat.LevelUp(stat.maxLevel - stat.level);
			}
			
			GiveBody(-100);
		}

		if (giveall || name ~== "backpack")
		{
			// Select the correct type of backpack based on the game
			type = (class<Inventory>)(gameinfo.backpacktype);
			if (type)
				GiveInventory(type, 1, true);

			if (!giveall)
				return;
		}

		if (giveall || name ~== "ammo")
		{
			// Find every unique type of ammo. Give it to the player if
			// he doesn't have it already, and set each to its maximum.
			for (i = 0; i < AllActorClasses.Size(); ++i)
			{
				let ammotype = (class<Ammo>)(AllActorClasses[i]);

				if (ammotype && GetDefaultByType(ammotype).GetParentAmmo() == ammotype)
				{
					let ammoitem = FindInventory(ammotype);
					if (!ammoitem)
					{
						ammoitem = Inventory(Spawn(ammotype));
						ammoitem.AttachToOwner(self);
						ammoitem.Amount = ammoitem.MaxAmount;
					}
					else if (ammoitem.Amount < ammoitem.MaxAmount)
						ammoitem.Amount = ammoitem.MaxAmount;
				}
			}

			if (!giveall)
				return;
		}

		if (giveall || name ~== "armor")
		{
			let chest = FindInventory("ChestPiece");
			if (chest)
				chest.health = chest.default.health;
			else
				GiveInventory("ChestPiece", 1);
			
			let helm = FindInventory("HelmetPiece");
			if (helm)
				helm.health = helm.default.health;
			else
				GiveInventory("HelmetPiece", 1);
			
			let amu = FindInventory("AmuletPiece");
			if (amu)
				amu.health = amu.default.health;
			else
				GiveInventory("AmuletPiece", 1);
			
			let brace = FindInventory("BracerPiece");
			if (brace)
				brace.health = brace.default.health;
			else
				GiveInventory("BracerPiece", 1);
			
			let shield = FindInventory("ShieldPiece");
			if (shield)
				shield.health = shield.default.health;
			else
				GiveInventory("ShieldPiece", 1);

			if (!giveall)
				return;
		}

		if (giveall || name ~== "keys")
		{
			for (int i = 0; i < AllActorClasses.Size(); ++i)
			{
				if (AllActorClasses[i] is "Key")
				{
					let keyitem = GetDefaultByType(AllActorClasses[i]);
					if (keyitem.special1 != 0)
					{
						let item = Inventory(Spawn(AllActorClasses[i]));
						if (!item.CallTryPickup(self))
							item.Destroy();
					}
				}
			}
			
			if (!giveall)
				return;
		}

		if (giveall || name ~== "weapons")
		{
			let savedpending = player.PendingWeapon;
			for (i = 0; i < AllActorClasses.Size(); ++i)
			{
				let type = (class<Weapon>)(AllActorClasses[i]);
				if (type && type != "Weapon")
				{
					// Don't give replaced weapons unless the replacement was done by Dehacked.
					let rep = GetReplacement(type);
					if (rep == type || rep is "DehackedPickup")
					{
						// Give the weapon only if it is set in a weapon slot.
						if (player.weapons.LocateWeapon(type))
						{
							readonly<Weapon> def = GetDefaultByType(type);
							if (giveall == ALL_YESYES || !def.bCheatNotWeapon)
								GiveInventory(type, 1, true);
						}
					}
				}
			}
			player.PendingWeapon = savedpending;

			if (!giveall)
				return;
		}

		if (giveall || name ~== "artifacts")
		{
			for (i = 0; i < AllActorClasses.Size(); ++i)
			{
				type = (class<Inventory>)(AllActorClasses[i]);
				if (type)
				{
					if (type is "ArtiInvulnerability2" || type is "ArtiDarkServant")
						continue;
					
					let def = GetDefaultByType(type);
					if (def.Icon.isValid() && def.MaxAmount > 1 &&
						!(type is "PuzzleItem") && !(type is "Powerup") && !(type is "Ammo") &&	!(type is "Armor"))
					{
						// Do not give replaced items unless using "give everything"
						if (giveall == ALL_YESYES || GetReplacement(type) == type)
							GiveInventory(type, amount <= 0 ? def.MaxAmount : amount, true);
					}
				}
			}
			
			if (!giveall)
				return;
		}

		if (giveall || name ~== "puzzlepieces")
		{
			for (i = 0; i < AllActorClasses.Size(); ++i)
			{
				let type = (class<PuzzleItem>)(AllActorClasses[i]);
				if (type)
				{
					let def = GetDefaultByType(type);
					if (def.Icon.isValid())
					{
						// Do not give replaced items unless using "give everything"
						if (giveall == ALL_YESYES || GetReplacement(type) == type)
							GiveInventory(type, amount <= 0 ? def.MaxAmount : amount, true);
					}
				}
			}
			
			if (!giveall)
				return;
		}
		
		if (giveall)
			return;

		type = name;
		if (!type)
		{
			if (PlayerNumber() == consoleplayer)
				A_Log(String.Format("Unknown item \"%s\"\n", name));
		}
		else
			GiveInventory(type, amount, true);
	}
	
	override void MovePlayer()
	{
		let wpn = RPGMelee(player.ReadyWeapon);
		if (wpn && wpn.bCancelled)
		{
			if (abs(player.cmd.forwardmove) > gameinfo.normforwardmove[0]*256)
				player.cmd.forwardmove = gameinfo.normforwardmove[0]*256*GetSign(player.cmd.forwardmove);
					
			if (abs(player.cmd.sidemove) > gameinfo.normsidemove[0]*256)
				player.cmd.sidemove = gameinfo.normsidemove[0]*256*GetSign(player.cmd.sidemove);
		}
		
		super.MovePlayer();
	}
	
	private int GetSign(double num)
	{
		if (num >= 0)
			return 1;
		else
			return -1;
	}
}