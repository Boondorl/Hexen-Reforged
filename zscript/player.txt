enum EHideTypes
{
	EL_ITEMS = 1,
	EL_SKILLS = 1<<1
}

class RPGPlayer : PlayerPawn abstract
{
	Array<Stat> stats;
	Array<Skill> skills;
	Array<Skill> activeSkills;
	uint selectedSkill;
	
	ui int currentPoints;
	ui int hideElements;
	
	int carryCapacity;
	int maxLevel;
	int skillSlots;
	int currentLevel;
	double currentXP;
	double nextLevelXP;
	int points;
	double coolDownModifier;
	double attackModifier;
	
	int currentCapacity;
	
	property CarryCapacity : carryCapacity;
	property MaxLevel : maxLevel;
	property SkillSlots : skillSlots;
	property StartLevel : currentLevel;
	property StartRequiredXP : nextLevelXP;
	property StartPoints : points;
	property StartXP : currentXP;
	property CoolDownModifier : coolDownModifier;
	property AttackModifier : attackModifier;
	
	Default
	{
		Player.MaxHealth 100;
		Health 100;
		Speed 0.85;
		PainChance 256;
		ReactionTime 0;
		RPGPlayer.CoolDownModifier 1;
		RPGPlayer.AttackModifier 1;
		RPGPlayer.CarryCapacity 100;
		RPGPlayer.MaxLevel 11;
		RPGPlayer.SkillSlots 3;
		RPGPlayer.StartLevel 1;
		RPGPlayer.StartRequiredXP 2000;
		
		+NODAMAGETHRUST
		+PLAYERPAWN.NOTHRUSTWHENINVUL
	}
	
	override void Tick()
	{
		super.Tick();
		
		if (!player || !player.mo || player.mo != self)
			return;
			
		let first = FirstInv();
		if (!first || !first.NextInv())
			player.inventorytics = 0;
		
		if (currentLevel < maxLevel && currentXP >= nextLevelXP)
			LevelUp();
		
		currentCapacity = 0;
		for (let probe = first; probe; probe = probe.NextInv())
		{
			let rpgi = RPGItem(probe);
			if (rpgi)
				currentCapacity += rpgi.amount*rpgi.weight;
		}
	}
	
	override void GiveDefaultInventory()
	{
		super.GiveDefaultInventory();
		
		for (uint i = 0; i < stats.Size(); ++i)
		{
			if (stats[i])
				stats[i].GiveDefault();
		}
	}
	
	void UseSkill(uint slot)
	{
		if (slot >= skillSlots)
			return;
		
		if (!activeSkills[slot])
			Console.Printf("No skill available");
		else
			activeSkills[slot].Use(false);
	}
	
	virtual void LevelUp()
	{
		currentXP -= nextLevelXP;
		if (currentXP < 0)
			currentXP = 0;
		
		nextLevelXP += default.nextLevelXP;
		
		++currentLevel;
		++points;
	}
	
	virtual void InitializeStats()
	{
		AddStat('Agility');
		AddStat('Vitality');
		AddStat('Wisdom');
		AddStat('Intelligence');
		AddStat('Strength');
		AddStat('Dexterity');
	}
	
	virtual void InitializeSkills() {}
	
	protected void AddStat(class<Stat> stat)
	{
		if (!stat)
			return;
		
		let st = Stat(Spawn(stat));
		if (st)
		{
			if (st.CallTryPickup(self))
				stats.Push(st);
			else
				st.Destroy();
		}
	}
	
	protected void AddSkill(class<Skill> skill)
	{
		if (!skill)
			return;
		
		let sk = Skill(Spawn(skill));
		if (sk)
		{
			if (sk.CallTryPickup(self))
				skills.Push(sk);
			else
				sk.Destroy();
		}
	}
	
	void SetActiveSkill(uint slot, class<Skill> skill = null)
	{
		if (slot >= skillSlots)
			return;
		
		if (activeSkills[slot])
		{
			activeSkills[slot].bCurToggle = false;
			activeSkills[slot].bActive = false;
			activeSkills[slot].EndSkill();
			activeSkills[slot].OnUnequip();
		}
		
		let newSkill = Skill(FindInventory(skill));
		activeSkills[slot] = newSkill;
		if (newSkill)
		{
			newSkill.bActive = true;
			newSkill.OnEquip();
		}
	}
	
	void NextSpell()
	{
		uint i = selectedSkill + 1;
		for (; i != selectedSkill; ++i)
		{
			if (i >= skillSlots)
				i = 0;
			
			if (activeSkills[i])
				break;
		}
		
		if (i != selectedSkill)
			selectedSkill = i;
	}
	
	void PreviousSpell()
	{
		int i = selectedSkill - 1;
		for (; i != selectedSkill; --i)
		{
			if (i < 0)
				i = skillSlots - 1;
			
			if (activeSkills[i])
				break;
		}
		
		if (i != selectedSkill)
			selectedSkill = i;
	}
	
	override void PostBeginPlay()
	{
		super.PostBeginPlay();
		
		GiveInventoryType("ArmorPieceManager");
		GiveInventoryType("BuffManager");
		
		activeSkills.Resize(skillSlots);
		InitializeStats();
		InitializeSkills();
	}
	
	override void CheatGive(String name, int amount)
	{
		int i;
		class<Inventory> type;

		if (!player.mo || player.health <= 0)
			return;

		int giveall = ALL_NO;
		if (name ~== "all")
			giveall = ALL_YES;
		else if (name ~== "everything")
			giveall = ALL_YESYES;

		if (name ~== "health")
		{
			if (amount > 0)
			{
				health += amount;
				player.health = health;
			}
			else
				player.health = health = GetMaxHealth(true);
			
			return;
		}
		else if (name ~== "level")
		{
			for (int i = 0; i < amount; ++i)
				LevelUp();
			
			return;
		}
		else if (name ~== "xp")
		{
			currentXP += amount;
			return;
		}
		else if (name ~== "point")
		{
			points += amount;
			return;
		}
		
		if (giveall)
		{
			for (int i = currentLevel; i < maxLevel; ++i)
				LevelUp();
			
			points = 0;
			currentXP = nextLevelXP;
			
			for (uint i = 0; i < stats.Size(); ++i)
			{
				if (stats[i])
					stats[i].LevelUp(stats[i].maxLevel - stats[i].level);
			}
			
			GiveBody(-100);
		}

		if (giveall || name ~== "backpack")
		{
			// Select the correct type of backpack based on the game
			type = (class<Inventory>)(gameinfo.backpacktype);
			if (type)
				GiveInventory(type, 1, true);

			if (!giveall)
				return;
		}

		if (giveall || name ~== "ammo")
		{
			// Find every unique type of ammo. Give it to the player if
			// he doesn't have it already, and set each to its maximum.
			for (i = 0; i < AllActorClasses.Size(); ++i)
			{
				let ammotype = (class<Ammo>)(AllActorClasses[i]);

				if (ammotype && GetDefaultByType(ammotype).GetParentAmmo() == ammotype)
				{
					let ammoitem = FindInventory(ammotype);
					if (!ammoitem)
					{
						ammoitem = Inventory(Spawn(ammotype));
						ammoitem.AttachToOwner(self);
						ammoitem.Amount = ammoitem.MaxAmount;
					}
					else if (ammoitem.Amount < ammoitem.MaxAmount)
						ammoitem.Amount = ammoitem.MaxAmount;
				}
			}

			if (!giveall)
				return;
		}

		if (giveall || name ~== "armor")
		{
			let chest = FindInventory("ChestPiece");
			if (chest)
				chest.health = chest.default.health;
			else
				GiveInventory("ChestPiece", 1);
			
			let helm = FindInventory("HelmetPiece");
			if (helm)
				helm.health = helm.default.health;
			else
				GiveInventory("HelmetPiece", 1);
			
			let amu = FindInventory("AmuletPiece");
			if (amu)
				amu.health = amu.default.health;
			else
				GiveInventory("AmuletPiece", 1);
			
			let brace = FindInventory("BracerPiece");
			if (brace)
				brace.health = brace.default.health;
			else
				GiveInventory("BracerPiece", 1);
			
			let shield = FindInventory("ShieldPiece");
			if (shield)
				shield.health = shield.default.health;
			else
				GiveInventory("ShieldPiece", 1);

			if (!giveall)
				return;
		}

		if (giveall || name ~== "keys")
		{
			for (int i = 0; i < AllActorClasses.Size(); ++i)
			{
				if (AllActorClasses[i] is "Key")
				{
					let keyitem = GetDefaultByType(AllActorClasses[i]);
					if (keyitem.special1 != 0)
					{
						let item = Inventory(Spawn(AllActorClasses[i]));
						if (!item.CallTryPickup(self))
							item.Destroy();
					}
				}
			}
			
			if (!giveall)
				return;
		}

		if (giveall || name ~== "weapons")
		{
			let savedpending = player.PendingWeapon;
			for (i = 0; i < AllActorClasses.Size(); ++i)
			{
				let type = (class<Weapon>)(AllActorClasses[i]);
				if (type && type != "Weapon")
				{
					// Don't give replaced weapons unless the replacement was done by Dehacked.
					let rep = GetReplacement(type);
					if (rep == type || rep is "DehackedPickup")
					{
						// Give the weapon only if it is set in a weapon slot.
						if (player.weapons.LocateWeapon(type))
						{
							readonly<Weapon> def = GetDefaultByType(type);
							if (giveall == ALL_YESYES || !def.bCheatNotWeapon)
								GiveInventory(type, 1, true);
						}
					}
				}
			}
			player.PendingWeapon = savedpending;

			if (!giveall)
				return;
		}

		if (giveall || name ~== "artifacts")
		{
			for (i = 0; i < AllActorClasses.Size(); ++i)
			{
				type = (class<Inventory>)(AllActorClasses[i]);
				if (type)
				{
					if (type is "ArtiInvulnerability2" || type is "ArtiDarkServant")
						continue;
					
					let def = GetDefaultByType(type);
					if (def.Icon.isValid() && def.MaxAmount > 1 &&
						!(type is "PuzzleItem") && !(type is "Powerup") && !(type is "Ammo") &&	!(type is "Armor"))
					{
						// Do not give replaced items unless using "give everything"
						if (giveall == ALL_YESYES || GetReplacement(type) == type)
							GiveInventory(type, amount <= 0 ? def.MaxAmount : amount, true);
					}
				}
			}
			
			if (!giveall)
				return;
		}

		if (giveall || name ~== "puzzlepieces")
		{
			for (i = 0; i < AllActorClasses.Size(); ++i)
			{
				let type = (class<PuzzleItem>)(AllActorClasses[i]);
				if (type)
				{
					let def = GetDefaultByType(type);
					if (def.Icon.isValid())
					{
						// Do not give replaced items unless using "give everything"
						if (giveall == ALL_YESYES || GetReplacement(type) == type)
							GiveInventory(type, amount <= 0 ? def.MaxAmount : amount, true);
					}
				}
			}
			
			if (!giveall)
				return;
		}
		
		if (giveall)
			return;

		type = name;
		if (!type)
		{
			if (PlayerNumber() == consoleplayer)
				A_Log(String.Format("Unknown item \"%s\"\n", name));
		}
		else
			GiveInventory(type, amount, true);
	}
	
	override void MovePlayer()
	{
		let wpn = RPGMelee(player.ReadyWeapon);
		if (wpn && wpn.bCancelled)
		{
			if (abs(player.cmd.forwardmove) > gameinfo.normforwardmove[0]*256)
				player.cmd.forwardmove = gameinfo.normforwardmove[0]*256*GetSign(player.cmd.forwardmove);
					
			if (abs(player.cmd.sidemove) > gameinfo.normsidemove[0]*256)
				player.cmd.sidemove = gameinfo.normsidemove[0]*256*GetSign(player.cmd.sidemove);
		}
		
		super.MovePlayer();
	}
	
	private int GetSign(double num)
	{
		if (num >= 0)
			return 1;
		else
			return -1;
	}
}